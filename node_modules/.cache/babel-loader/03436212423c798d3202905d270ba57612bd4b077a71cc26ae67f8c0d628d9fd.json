{"ast":null,"code":"import { toHexString } from \"./strings\";\n/**\n * Encodes a string to UTF-8.\n *\n * @param input The string to be encoded.\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\n *                      to the start of the encoding. (default `true`)\n * @returns A Uint8Array containing the UTF-8 encoding of the input string.\n *\n * -----------------------------------------------------------------------------\n *\n * JavaScript strings are composed of Unicode code points. Code points are\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\n * This function implements the UTF-8 encoding form.\n *\n * -----------------------------------------------------------------------------\n *\n * In UTF-8, each code point is mapped to a sequence of 1, 2, 3, or 4 bytes.\n * Note that the logic which defines this mapping is slightly convoluted, and\n * not as straightforward as the mapping logic for UTF-16 or UTF-32. The UTF-8\n * mapping logic is as follows [2]:\n *\n * â€¢ If a code point is in the range U+0000..U+007F, then view it as a 7-bit\n *   integer: 0bxxxxxxx. Map the code point to 1 byte with the first high order\n *   bit set to 0:\n *\n *       b1=0b0xxxxxxx\n *\n * â€¢ If a code point is in the range U+0080..U+07FF, then view it as an 11-bit\n *   integer: 0byyyyyxxxxxx. Map the code point to 2 bytes with the first 5 bits\n *   of the code point stored in the first byte, and the last 6 bits stored in\n *   the second byte:\n *\n *       b1=0b110yyyyy    b2=0b10xxxxxx\n *\n * â€¢ If a code point is in the range U+0800..U+FFFF, then view it as a 16-bit\n *   integer, 0bzzzzyyyyyyxxxxxx. Map the code point to 3 bytes with the first\n *   4 bits stored in the first byte, the next 6 bits stored in the second byte,\n *   and the last 6 bits in the third byte:\n *\n *       b1=0b1110zzzz    b2=0b10yyyyyy    b3=0b10xxxxxx\n *\n * â€¢ If a code point is in the range U+10000...U+10FFFF, then view it as a\n *   21-bit integer, 0bvvvzzzzzzyyyyyyxxxxxx. Map the code point to 4 bytes with\n *   the first 3 bits stored in the first byte, the next 6 bits stored in the\n *   second byte, the next 6 bits stored in the third byte, and the last 6 bits\n *   stored in the fourth byte:\n *\n *       b1=0b11110xxx    b2=0b10zzzzzz    b3=0b10yyyyyy    b4=0b10xxxxxx\n *\n * -----------------------------------------------------------------------------\n *\n * It is important to note, when iterating through the code points of a string\n * in JavaScript, that if a character is encoded as a surrogate pair it will\n * increase the string's length by 2 instead of 1 [4]. For example:\n *\n * ```\n * > 'a'.length\n * 1\n * > 'ðŸ’©'.length\n * 2\n * > 'èªž'.length\n * 1\n * > 'aðŸ’©èªž'.length\n * 4\n * ```\n *\n * The results of the above example are explained by the fact that the\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\n *\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\n * we must \"jump\" an extra index after encoding a character as a surrogate\n * pair. In practice, this means we must increment the index of our for loop by\n * 2 if we encode a surrogate pair, and 1 in all other cases.\n *\n * -----------------------------------------------------------------------------\n *\n * References:\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\n *         3.9  Unicode Encoding Forms - UTF-8\n *   - [2] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding.html\n *   - [3] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding-Algorithm.html\n *   - [4] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\n *\n */\nexport var utf8Encode = function (input, byteOrderMark) {\n  if (byteOrderMark === void 0) {\n    byteOrderMark = true;\n  }\n  var encoded = [];\n  if (byteOrderMark) encoded.push(0xef, 0xbb, 0xbf);\n  for (var idx = 0, len = input.length; idx < len;) {\n    var codePoint = input.codePointAt(idx);\n    // One byte encoding\n    if (codePoint < 0x80) {\n      var byte1 = codePoint & 0x7f;\n      encoded.push(byte1);\n      idx += 1;\n    }\n    // Two byte encoding\n    else if (codePoint < 0x0800) {\n      var byte1 = codePoint >> 6 & 0x1f | 0xc0;\n      var byte2 = codePoint & 0x3f | 0x80;\n      encoded.push(byte1, byte2);\n      idx += 1;\n    }\n    // Three byte encoding\n    else if (codePoint < 0x010000) {\n      var byte1 = codePoint >> 12 & 0x0f | 0xe0;\n      var byte2 = codePoint >> 6 & 0x3f | 0x80;\n      var byte3 = codePoint & 0x3f | 0x80;\n      encoded.push(byte1, byte2, byte3);\n      idx += 1;\n    }\n    // Four byte encoding (surrogate pair)\n    else if (codePoint < 0x110000) {\n      var byte1 = codePoint >> 18 & 0x07 | 0xf0;\n      var byte2 = codePoint >> 12 & 0x3f | 0x80;\n      var byte3 = codePoint >> 6 & 0x3f | 0x80;\n      var byte4 = codePoint >> 0 & 0x3f | 0x80;\n      encoded.push(byte1, byte2, byte3, byte4);\n      idx += 2;\n    }\n    // Should never reach this case\n    else throw new Error(\"Invalid code point: 0x\" + toHexString(codePoint));\n  }\n  return new Uint8Array(encoded);\n};\n/**\n * Encodes a string to UTF-16.\n *\n * @param input The string to be encoded.\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\n *                      to the start of the encoding. (default `true`)\n * @returns A Uint16Array containing the UTF-16 encoding of the input string.\n *\n * -----------------------------------------------------------------------------\n *\n * JavaScript strings are composed of Unicode code points. Code points are\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\n * This function implements the UTF-16 encoding form.\n *\n * -----------------------------------------------------------------------------\n *\n * In UTF-16, each code point is mapped to one or two 16-bit integers. The\n * UTF-16 mapping logic is as follows [2]:\n *\n * â€¢ If a code point is in the range U+0000..U+FFFF, then map the code point to\n *   a 16-bit integer with the most significant byte first.\n *\n * â€¢ If a code point is in the range U+10000..U+10000, then map the code point\n *   to two 16-bit integers. The first integer should contain the high surrogate\n *   and the second integer should contain the low surrogate. Both surrogates\n *   should be written with the most significant byte first.\n *\n * -----------------------------------------------------------------------------\n *\n * It is important to note, when iterating through the code points of a string\n * in JavaScript, that if a character is encoded as a surrogate pair it will\n * increase the string's length by 2 instead of 1 [4]. For example:\n *\n * ```\n * > 'a'.length\n * 1\n * > 'ðŸ’©'.length\n * 2\n * > 'èªž'.length\n * 1\n * > 'aðŸ’©èªž'.length\n * 4\n * ```\n *\n * The results of the above example are explained by the fact that the\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\n *\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\n * we must \"jump\" an extra index after encoding a character as a surrogate\n * pair. In practice, this means we must increment the index of our for loop by\n * 2 if we encode a surrogate pair, and 1 in all other cases.\n *\n * -----------------------------------------------------------------------------\n *\n * References:\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\n *         3.9  Unicode Encoding Forms - UTF-8\n *   - [2] http://www.herongyang.com/Unicode/UTF-16-UTF-16-Encoding.html\n *   - [3] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\n *\n */\nexport var utf16Encode = function (input, byteOrderMark) {\n  if (byteOrderMark === void 0) {\n    byteOrderMark = true;\n  }\n  var encoded = [];\n  if (byteOrderMark) encoded.push(0xfeff);\n  for (var idx = 0, len = input.length; idx < len;) {\n    var codePoint = input.codePointAt(idx);\n    // Two byte encoding\n    if (codePoint < 0x010000) {\n      encoded.push(codePoint);\n      idx += 1;\n    }\n    // Four byte encoding (surrogate pair)\n    else if (codePoint < 0x110000) {\n      encoded.push(highSurrogate(codePoint), lowSurrogate(codePoint));\n      idx += 2;\n    }\n    // Should never reach this case\n    else throw new Error(\"Invalid code point: 0x\" + toHexString(codePoint));\n  }\n  return new Uint16Array(encoded);\n};\n/**\n * Returns `true` if the `codePoint` is within the\n * Basic Multilingual Plane (BMP). Code points inside the BMP are not encoded\n * with surrogate pairs.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nexport var isWithinBMP = function (codePoint) {\n  return codePoint >= 0 && codePoint <= 0xffff;\n};\n/**\n * Returns `true` if the given `codePoint` is valid and must be represented\n * with a surrogate pair when encoded.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nexport var hasSurrogates = function (codePoint) {\n  return codePoint >= 0x010000 && codePoint <= 0x10ffff;\n};\n// From Unicode 3.0 spec, section 3.7:\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\nexport var highSurrogate = function (codePoint) {\n  return Math.floor((codePoint - 0x10000) / 0x400) + 0xd800;\n};\n// From Unicode 3.0 spec, section 3.7:\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\nexport var lowSurrogate = function (codePoint) {\n  return (codePoint - 0x10000) % 0x400 + 0xdc00;\n};\nvar ByteOrder;\n(function (ByteOrder) {\n  ByteOrder[\"BigEndian\"] = \"BigEndian\";\n  ByteOrder[\"LittleEndian\"] = \"LittleEndian\";\n})(ByteOrder || (ByteOrder = {}));\nvar REPLACEMENT = 'ï¿½'.codePointAt(0);\n/**\n * Decodes a Uint8Array of data to a string using UTF-16.\n *\n * Note that this function attempts to recover from erronous input by\n * inserting the replacement character (ï¿½) to mark invalid code points\n * and surrogate pairs.\n *\n * @param input A Uint8Array containing UTF-16 encoded data\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be read\n *                      at the start of the encoding. (default `true`)\n * @returns The decoded string.\n */\nexport var utf16Decode = function (input, byteOrderMark) {\n  if (byteOrderMark === void 0) {\n    byteOrderMark = true;\n  }\n  // Need at least 2 bytes of data in UTF-16 encodings\n  if (input.length <= 1) return String.fromCodePoint(REPLACEMENT);\n  var byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian;\n  // Skip byte order mark if needed\n  var idx = byteOrderMark ? 2 : 0;\n  var codePoints = [];\n  while (input.length - idx >= 2) {\n    var first = decodeValues(input[idx++], input[idx++], byteOrder);\n    if (isHighSurrogate(first)) {\n      if (input.length - idx < 2) {\n        // Need at least 2 bytes left for the low surrogate that is required\n        codePoints.push(REPLACEMENT);\n      } else {\n        var second = decodeValues(input[idx++], input[idx++], byteOrder);\n        if (isLowSurrogate(second)) {\n          codePoints.push(first, second);\n        } else {\n          // Low surrogates should always follow high surrogates\n          codePoints.push(REPLACEMENT);\n        }\n      }\n    } else if (isLowSurrogate(first)) {\n      // High surrogates should always come first since `decodeValues()`\n      // accounts for the byte ordering\n      idx += 2;\n      codePoints.push(REPLACEMENT);\n    } else {\n      codePoints.push(first);\n    }\n  }\n  // There shouldn't be extra byte(s) left over\n  if (idx < input.length) codePoints.push(REPLACEMENT);\n  return String.fromCodePoint.apply(String, codePoints);\n};\n/**\n * Returns `true` if the given `codePoint` is a high surrogate.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nvar isHighSurrogate = function (codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n};\n/**\n * Returns `true` if the given `codePoint` is a low surrogate.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nvar isLowSurrogate = function (codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n};\n/**\n * Decodes the given utf-16 values first and second using the specified\n * byte order.\n * @param first The first byte of the encoding.\n * @param second The second byte of the encoding.\n * @param byteOrder The byte order of the encoding.\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Examples\n */\nvar decodeValues = function (first, second, byteOrder) {\n  // Append the binary representation of the preceding byte by shifting the\n  // first one 8 to the left and than applying a bitwise or-operator to append\n  // the second one.\n  if (byteOrder === ByteOrder.LittleEndian) return second << 8 | first;\n  if (byteOrder === ByteOrder.BigEndian) return first << 8 | second;\n  throw new Error(\"Invalid byteOrder: \" + byteOrder);\n};\n/**\n * Returns whether the given array contains a byte order mark for the\n * UTF-16BE or UTF-16LE encoding. If it has neither, BigEndian is assumed.\n *\n * Reference: https://en.wikipedia.org/wiki/Byte_order_mark#UTF-16\n *\n * @param bytes The byte array to be evaluated.\n */\n// prettier-ignore\nvar readBOM = function (bytes) {\n  return hasUtf16BigEndianBOM(bytes) ? ByteOrder.BigEndian : hasUtf16LittleEndianBOM(bytes) ? ByteOrder.LittleEndian : ByteOrder.BigEndian;\n};\nvar hasUtf16BigEndianBOM = function (bytes) {\n  return bytes[0] === 0xfe && bytes[1] === 0xff;\n};\nvar hasUtf16LittleEndianBOM = function (bytes) {\n  return bytes[0] === 0xff && bytes[1] === 0xfe;\n};\nexport var hasUtf16BOM = function (bytes) {\n  return hasUtf16BigEndianBOM(bytes) || hasUtf16LittleEndianBOM(bytes);\n};","map":{"version":3,"names":["toHexString","utf8Encode","input","byteOrderMark","encoded","push","idx","len","length","codePoint","codePointAt","byte1","byte2","byte3","byte4","Error","Uint8Array","utf16Encode","highSurrogate","lowSurrogate","Uint16Array","isWithinBMP","hasSurrogates","Math","floor","ByteOrder","REPLACEMENT","utf16Decode","String","fromCodePoint","byteOrder","readBOM","BigEndian","codePoints","first","decodeValues","isHighSurrogate","second","isLowSurrogate","apply","LittleEndian","bytes","hasUtf16BigEndianBOM","hasUtf16LittleEndianBOM","hasUtf16BOM"],"sources":["C:\\Users\\TongNPZ\\Desktop\\my-app-2.0\\node_modules\\pdf-lib\\src\\utils\\unicode.ts"],"sourcesContent":["import { toHexString } from 'src/utils/strings';\n\n/**\n * Encodes a string to UTF-8.\n *\n * @param input The string to be encoded.\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\n *                      to the start of the encoding. (default `true`)\n * @returns A Uint8Array containing the UTF-8 encoding of the input string.\n *\n * -----------------------------------------------------------------------------\n *\n * JavaScript strings are composed of Unicode code points. Code points are\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\n * This function implements the UTF-8 encoding form.\n *\n * -----------------------------------------------------------------------------\n *\n * In UTF-8, each code point is mapped to a sequence of 1, 2, 3, or 4 bytes.\n * Note that the logic which defines this mapping is slightly convoluted, and\n * not as straightforward as the mapping logic for UTF-16 or UTF-32. The UTF-8\n * mapping logic is as follows [2]:\n *\n * â€¢ If a code point is in the range U+0000..U+007F, then view it as a 7-bit\n *   integer: 0bxxxxxxx. Map the code point to 1 byte with the first high order\n *   bit set to 0:\n *\n *       b1=0b0xxxxxxx\n *\n * â€¢ If a code point is in the range U+0080..U+07FF, then view it as an 11-bit\n *   integer: 0byyyyyxxxxxx. Map the code point to 2 bytes with the first 5 bits\n *   of the code point stored in the first byte, and the last 6 bits stored in\n *   the second byte:\n *\n *       b1=0b110yyyyy    b2=0b10xxxxxx\n *\n * â€¢ If a code point is in the range U+0800..U+FFFF, then view it as a 16-bit\n *   integer, 0bzzzzyyyyyyxxxxxx. Map the code point to 3 bytes with the first\n *   4 bits stored in the first byte, the next 6 bits stored in the second byte,\n *   and the last 6 bits in the third byte:\n *\n *       b1=0b1110zzzz    b2=0b10yyyyyy    b3=0b10xxxxxx\n *\n * â€¢ If a code point is in the range U+10000...U+10FFFF, then view it as a\n *   21-bit integer, 0bvvvzzzzzzyyyyyyxxxxxx. Map the code point to 4 bytes with\n *   the first 3 bits stored in the first byte, the next 6 bits stored in the\n *   second byte, the next 6 bits stored in the third byte, and the last 6 bits\n *   stored in the fourth byte:\n *\n *       b1=0b11110xxx    b2=0b10zzzzzz    b3=0b10yyyyyy    b4=0b10xxxxxx\n *\n * -----------------------------------------------------------------------------\n *\n * It is important to note, when iterating through the code points of a string\n * in JavaScript, that if a character is encoded as a surrogate pair it will\n * increase the string's length by 2 instead of 1 [4]. For example:\n *\n * ```\n * > 'a'.length\n * 1\n * > 'ðŸ’©'.length\n * 2\n * > 'èªž'.length\n * 1\n * > 'aðŸ’©èªž'.length\n * 4\n * ```\n *\n * The results of the above example are explained by the fact that the\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\n *\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\n * we must \"jump\" an extra index after encoding a character as a surrogate\n * pair. In practice, this means we must increment the index of our for loop by\n * 2 if we encode a surrogate pair, and 1 in all other cases.\n *\n * -----------------------------------------------------------------------------\n *\n * References:\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\n *         3.9  Unicode Encoding Forms - UTF-8\n *   - [2] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding.html\n *   - [3] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding-Algorithm.html\n *   - [4] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\n *\n */\nexport const utf8Encode = (input: string, byteOrderMark = true): Uint8Array => {\n  const encoded = [];\n\n  if (byteOrderMark) encoded.push(0xef, 0xbb, 0xbf);\n\n  for (let idx = 0, len = input.length; idx < len; ) {\n    const codePoint = input.codePointAt(idx)!;\n\n    // One byte encoding\n    if (codePoint < 0x80) {\n      const byte1 = codePoint & 0x7f;\n      encoded.push(byte1);\n      idx += 1;\n    }\n\n    // Two byte encoding\n    else if (codePoint < 0x0800) {\n      const byte1 = ((codePoint >> 6) & 0x1f) | 0xc0;\n      const byte2 = (codePoint & 0x3f) | 0x80;\n      encoded.push(byte1, byte2);\n      idx += 1;\n    }\n\n    // Three byte encoding\n    else if (codePoint < 0x010000) {\n      const byte1 = ((codePoint >> 12) & 0x0f) | 0xe0;\n      const byte2 = ((codePoint >> 6) & 0x3f) | 0x80;\n      const byte3 = (codePoint & 0x3f) | 0x80;\n      encoded.push(byte1, byte2, byte3);\n      idx += 1;\n    }\n\n    // Four byte encoding (surrogate pair)\n    else if (codePoint < 0x110000) {\n      const byte1 = ((codePoint >> 18) & 0x07) | 0xf0;\n      const byte2 = ((codePoint >> 12) & 0x3f) | 0x80;\n      const byte3 = ((codePoint >> 6) & 0x3f) | 0x80;\n      const byte4 = ((codePoint >> 0) & 0x3f) | 0x80;\n      encoded.push(byte1, byte2, byte3, byte4);\n      idx += 2;\n    }\n\n    // Should never reach this case\n    else throw new Error(`Invalid code point: 0x${toHexString(codePoint)}`);\n  }\n\n  return new Uint8Array(encoded);\n};\n\n/**\n * Encodes a string to UTF-16.\n *\n * @param input The string to be encoded.\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\n *                      to the start of the encoding. (default `true`)\n * @returns A Uint16Array containing the UTF-16 encoding of the input string.\n *\n * -----------------------------------------------------------------------------\n *\n * JavaScript strings are composed of Unicode code points. Code points are\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\n * This function implements the UTF-16 encoding form.\n *\n * -----------------------------------------------------------------------------\n *\n * In UTF-16, each code point is mapped to one or two 16-bit integers. The\n * UTF-16 mapping logic is as follows [2]:\n *\n * â€¢ If a code point is in the range U+0000..U+FFFF, then map the code point to\n *   a 16-bit integer with the most significant byte first.\n *\n * â€¢ If a code point is in the range U+10000..U+10000, then map the code point\n *   to two 16-bit integers. The first integer should contain the high surrogate\n *   and the second integer should contain the low surrogate. Both surrogates\n *   should be written with the most significant byte first.\n *\n * -----------------------------------------------------------------------------\n *\n * It is important to note, when iterating through the code points of a string\n * in JavaScript, that if a character is encoded as a surrogate pair it will\n * increase the string's length by 2 instead of 1 [4]. For example:\n *\n * ```\n * > 'a'.length\n * 1\n * > 'ðŸ’©'.length\n * 2\n * > 'èªž'.length\n * 1\n * > 'aðŸ’©èªž'.length\n * 4\n * ```\n *\n * The results of the above example are explained by the fact that the\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\n *\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\n * we must \"jump\" an extra index after encoding a character as a surrogate\n * pair. In practice, this means we must increment the index of our for loop by\n * 2 if we encode a surrogate pair, and 1 in all other cases.\n *\n * -----------------------------------------------------------------------------\n *\n * References:\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\n *         3.9  Unicode Encoding Forms - UTF-8\n *   - [2] http://www.herongyang.com/Unicode/UTF-16-UTF-16-Encoding.html\n *   - [3] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\n *\n */\nexport const utf16Encode = (\n  input: string,\n  byteOrderMark = true,\n): Uint16Array => {\n  const encoded = [];\n\n  if (byteOrderMark) encoded.push(0xfeff);\n\n  for (let idx = 0, len = input.length; idx < len; ) {\n    const codePoint = input.codePointAt(idx)!;\n\n    // Two byte encoding\n    if (codePoint < 0x010000) {\n      encoded.push(codePoint);\n      idx += 1;\n    }\n\n    // Four byte encoding (surrogate pair)\n    else if (codePoint < 0x110000) {\n      encoded.push(highSurrogate(codePoint), lowSurrogate(codePoint));\n      idx += 2;\n    }\n\n    // Should never reach this case\n    else throw new Error(`Invalid code point: 0x${toHexString(codePoint)}`);\n  }\n\n  return new Uint16Array(encoded);\n};\n\n/**\n * Returns `true` if the `codePoint` is within the\n * Basic Multilingual Plane (BMP). Code points inside the BMP are not encoded\n * with surrogate pairs.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nexport const isWithinBMP = (codePoint: number) =>\n  codePoint >= 0 && codePoint <= 0xffff;\n\n/**\n * Returns `true` if the given `codePoint` is valid and must be represented\n * with a surrogate pair when encoded.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nexport const hasSurrogates = (codePoint: number) =>\n  codePoint >= 0x010000 && codePoint <= 0x10ffff;\n\n// From Unicode 3.0 spec, section 3.7:\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\nexport const highSurrogate = (codePoint: number) =>\n  Math.floor((codePoint - 0x10000) / 0x400) + 0xd800;\n\n// From Unicode 3.0 spec, section 3.7:\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\nexport const lowSurrogate = (codePoint: number) =>\n  ((codePoint - 0x10000) % 0x400) + 0xdc00;\n\nenum ByteOrder {\n  BigEndian = 'BigEndian',\n  LittleEndian = 'LittleEndian',\n}\n\nconst REPLACEMENT = 'ï¿½'.codePointAt(0)!;\n\n/**\n * Decodes a Uint8Array of data to a string using UTF-16.\n *\n * Note that this function attempts to recover from erronous input by\n * inserting the replacement character (ï¿½) to mark invalid code points\n * and surrogate pairs.\n *\n * @param input A Uint8Array containing UTF-16 encoded data\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be read\n *                      at the start of the encoding. (default `true`)\n * @returns The decoded string.\n */\nexport const utf16Decode = (\n  input: Uint8Array,\n  byteOrderMark = true,\n): string => {\n  // Need at least 2 bytes of data in UTF-16 encodings\n  if (input.length <= 1) return String.fromCodePoint(REPLACEMENT);\n\n  const byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian;\n\n  // Skip byte order mark if needed\n  let idx = byteOrderMark ? 2 : 0;\n\n  const codePoints: number[] = [];\n\n  while (input.length - idx >= 2) {\n    const first = decodeValues(input[idx++], input[idx++], byteOrder);\n\n    if (isHighSurrogate(first)) {\n      if (input.length - idx < 2) {\n        // Need at least 2 bytes left for the low surrogate that is required\n        codePoints.push(REPLACEMENT);\n      } else {\n        const second = decodeValues(input[idx++], input[idx++], byteOrder);\n        if (isLowSurrogate(second)) {\n          codePoints.push(first, second);\n        } else {\n          // Low surrogates should always follow high surrogates\n          codePoints.push(REPLACEMENT);\n        }\n      }\n    } else if (isLowSurrogate(first)) {\n      // High surrogates should always come first since `decodeValues()`\n      // accounts for the byte ordering\n      idx += 2;\n      codePoints.push(REPLACEMENT);\n    } else {\n      codePoints.push(first);\n    }\n  }\n\n  // There shouldn't be extra byte(s) left over\n  if (idx < input.length) codePoints.push(REPLACEMENT);\n\n  return String.fromCodePoint(...codePoints);\n};\n\n/**\n * Returns `true` if the given `codePoint` is a high surrogate.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nconst isHighSurrogate = (codePoint: number) =>\n  codePoint >= 0xd800 && codePoint <= 0xdbff;\n\n/**\n * Returns `true` if the given `codePoint` is a low surrogate.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nconst isLowSurrogate = (codePoint: number) =>\n  codePoint >= 0xdc00 && codePoint <= 0xdfff;\n\n/**\n * Decodes the given utf-16 values first and second using the specified\n * byte order.\n * @param first The first byte of the encoding.\n * @param second The second byte of the encoding.\n * @param byteOrder The byte order of the encoding.\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Examples\n */\nconst decodeValues = (first: number, second: number, byteOrder: ByteOrder) => {\n  // Append the binary representation of the preceding byte by shifting the\n  // first one 8 to the left and than applying a bitwise or-operator to append\n  // the second one.\n  if (byteOrder === ByteOrder.LittleEndian) return (second << 8) | first;\n  if (byteOrder === ByteOrder.BigEndian) return (first << 8) | second;\n  throw new Error(`Invalid byteOrder: ${byteOrder}`);\n};\n\n/**\n * Returns whether the given array contains a byte order mark for the\n * UTF-16BE or UTF-16LE encoding. If it has neither, BigEndian is assumed.\n *\n * Reference: https://en.wikipedia.org/wiki/Byte_order_mark#UTF-16\n *\n * @param bytes The byte array to be evaluated.\n */\n// prettier-ignore\nconst readBOM = (bytes: Uint8Array): ByteOrder => (\n    hasUtf16BigEndianBOM(bytes) ? ByteOrder.BigEndian\n  : hasUtf16LittleEndianBOM(bytes) ? ByteOrder.LittleEndian\n  : ByteOrder.BigEndian\n);\n\nconst hasUtf16BigEndianBOM = (bytes: Uint8Array) =>\n  bytes[0] === 0xfe && bytes[1] === 0xff;\n\nconst hasUtf16LittleEndianBOM = (bytes: Uint8Array) =>\n  bytes[0] === 0xff && bytes[1] === 0xfe;\n\nexport const hasUtf16BOM = (bytes: Uint8Array) =>\n  hasUtf16BigEndianBOM(bytes) || hasUtf16LittleEndianBOM(bytes);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
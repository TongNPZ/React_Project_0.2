{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport PDFDocument from \"./PDFDocument\";\nimport { CustomFontEmbedder, PDFRef, StandardFontEmbedder } from \"../core\";\nimport { assertIs, assertOrUndefined } from \"../utils\";\n/**\r\n * Represents a font that has been embedded in a [[PDFDocument]].\r\n */\nvar PDFFont = /** @class */function () {\n  function PDFFont(ref, doc, embedder) {\n    this.modified = true;\n    assertIs(ref, 'ref', [[PDFRef, 'PDFRef']]);\n    assertIs(doc, 'doc', [[PDFDocument, 'PDFDocument']]);\n    assertIs(embedder, 'embedder', [[CustomFontEmbedder, 'CustomFontEmbedder'], [StandardFontEmbedder, 'StandardFontEmbedder']]);\n    this.ref = ref;\n    this.doc = doc;\n    this.name = embedder.fontName;\n    this.embedder = embedder;\n  }\n  /**\r\n   * > **NOTE:** You probably don't need to call this method directly. The\r\n   * > [[PDFPage.drawText]] method will automatically encode the text it is\r\n   * > given.\r\n   *\r\n   * Encodes a string of text in this font.\r\n   *\r\n   * @param text The text to be encoded.\r\n   * @returns The encoded text as a hex string.\r\n   */\n  PDFFont.prototype.encodeText = function (text) {\n    assertIs(text, 'text', ['string']);\n    this.modified = true;\n    return this.embedder.encodeText(text);\n  };\n  /**\r\n   * Measure the width of a string of text drawn in this font at a given size.\r\n   * For example:\r\n   * ```js\r\n   * const width = font.widthOfTextAtSize('Foo Bar Qux Baz', 36)\r\n   * ```\r\n   * @param text The string of text to be measured.\r\n   * @param size The font size to be used for this measurement.\r\n   * @returns The width of the string of text when drawn in this font at the\r\n   *          given size.\r\n   */\n  PDFFont.prototype.widthOfTextAtSize = function (text, size) {\n    assertIs(text, 'text', ['string']);\n    assertIs(size, 'size', ['number']);\n    return this.embedder.widthOfTextAtSize(text, size);\n  };\n  /**\r\n   * Measure the height of this font at a given size. For example:\r\n   * ```js\r\n   * const height = font.heightAtSize(24)\r\n   * ```\r\n   *\r\n   * The `options.descender` value controls whether or not the font's\r\n   * descender is included in the height calculation.\r\n   *\r\n   * @param size The font size to be used for this measurement.\r\n   * @param options The options to be used when computing this measurement.\r\n   * @returns The height of this font at the given size.\r\n   */\n  PDFFont.prototype.heightAtSize = function (size, options) {\n    var _a;\n    assertIs(size, 'size', ['number']);\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.descender, 'options.descender', ['boolean']);\n    return this.embedder.heightOfFontAtSize(size, {\n      descender: (_a = options === null || options === void 0 ? void 0 : options.descender) !== null && _a !== void 0 ? _a : true\n    });\n  };\n  /**\r\n   * Compute the font size at which this font is a given height. For example:\r\n   * ```js\r\n   * const fontSize = font.sizeAtHeight(12)\r\n   * ```\r\n   * @param height The height to be used for this calculation.\r\n   * @returns The font size at which this font is the given height.\r\n   */\n  PDFFont.prototype.sizeAtHeight = function (height) {\n    assertIs(height, 'height', ['number']);\n    return this.embedder.sizeOfFontAtHeight(height);\n  };\n  /**\r\n   * Get the set of unicode code points that can be represented by this font.\r\n   * @returns The set of unicode code points supported by this font.\r\n   */\n  PDFFont.prototype.getCharacterSet = function () {\n    if (this.embedder instanceof StandardFontEmbedder) {\n      return this.embedder.encoding.supportedCodePoints;\n    } else {\n      return this.embedder.font.characterSet;\n    }\n  };\n  /**\r\n   * > **NOTE:** You probably don't need to call this method directly. The\r\n   * > [[PDFDocument.save]] and [[PDFDocument.saveAsBase64]] methods will\r\n   * > automatically ensure all fonts get embedded.\r\n   *\r\n   * Embed this font in its document.\r\n   *\r\n   * @returns Resolves when the embedding is complete.\r\n   */\n  PDFFont.prototype.embed = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.modified) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.embedder.embedIntoContext(this.doc.context, this.ref)];\n          case 1:\n            _a.sent();\n            this.modified = false;\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\r\n   * > consider using the [[PDFDocument.embedFont]] and\r\n   * > [[PDFDocument.embedStandardFont]] methods, which will create instances\r\n   * > of [[PDFFont]] for you.\r\n   *\r\n   * Create an instance of [[PDFFont]] from an existing ref and embedder\r\n   *\r\n   * @param ref The unique reference for this font.\r\n   * @param doc The document to which the font will belong.\r\n   * @param embedder The embedder that will be used to embed the font.\r\n   */\n  PDFFont.of = function (ref, doc, embedder) {\n    return new PDFFont(ref, doc, embedder);\n  };\n  return PDFFont;\n}();\nexport default PDFFont;","map":{"version":3,"names":["PDFDocument","CustomFontEmbedder","PDFRef","StandardFontEmbedder","assertIs","assertOrUndefined","PDFFont","ref","doc","embedder","modified","name","fontName","prototype","encodeText","text","widthOfTextAtSize","size","heightAtSize","options","descender","heightOfFontAtSize","_a","sizeAtHeight","height","sizeOfFontAtHeight","getCharacterSet","encoding","supportedCodePoints","font","characterSet","embed","embedIntoContext","context","sent","of"],"sources":["C:\\Users\\TongNPZ\\Desktop\\my-app-2.0 - Copy (2)\\node_modules\\pdf-lib\\src\\api\\PDFFont.ts"],"sourcesContent":["import Embeddable from 'src/api//Embeddable';\r\nimport PDFDocument from 'src/api/PDFDocument';\r\nimport {\r\n  CustomFontEmbedder,\r\n  PDFHexString,\r\n  PDFRef,\r\n  StandardFontEmbedder,\r\n} from 'src/core';\r\nimport { assertIs, assertOrUndefined } from 'src/utils';\r\n\r\nexport type FontEmbedder = CustomFontEmbedder | StandardFontEmbedder;\r\n\r\n/**\r\n * Represents a font that has been embedded in a [[PDFDocument]].\r\n */\r\nexport default class PDFFont implements Embeddable {\r\n  /**\r\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\r\n   * > consider using the [[PDFDocument.embedFont]] and\r\n   * > [[PDFDocument.embedStandardFont]] methods, which will create instances\r\n   * > of [[PDFFont]] for you.\r\n   *\r\n   * Create an instance of [[PDFFont]] from an existing ref and embedder\r\n   *\r\n   * @param ref The unique reference for this font.\r\n   * @param doc The document to which the font will belong.\r\n   * @param embedder The embedder that will be used to embed the font.\r\n   */\r\n  static of = (ref: PDFRef, doc: PDFDocument, embedder: FontEmbedder) =>\r\n    new PDFFont(ref, doc, embedder);\r\n\r\n  /** The unique reference assigned to this font within the document. */\r\n  readonly ref: PDFRef;\r\n\r\n  /** The document to which this font belongs. */\r\n  readonly doc: PDFDocument;\r\n\r\n  /** The name of this font. */\r\n  readonly name: string;\r\n\r\n  private modified = true;\r\n  private readonly embedder: FontEmbedder;\r\n\r\n  private constructor(ref: PDFRef, doc: PDFDocument, embedder: FontEmbedder) {\r\n    assertIs(ref, 'ref', [[PDFRef, 'PDFRef']]);\r\n    assertIs(doc, 'doc', [[PDFDocument, 'PDFDocument']]);\r\n    assertIs(embedder, 'embedder', [\r\n      [CustomFontEmbedder, 'CustomFontEmbedder'],\r\n      [StandardFontEmbedder, 'StandardFontEmbedder'],\r\n    ]);\r\n\r\n    this.ref = ref;\r\n    this.doc = doc;\r\n    this.name = embedder.fontName;\r\n\r\n    this.embedder = embedder;\r\n  }\r\n\r\n  /**\r\n   * > **NOTE:** You probably don't need to call this method directly. The\r\n   * > [[PDFPage.drawText]] method will automatically encode the text it is\r\n   * > given.\r\n   *\r\n   * Encodes a string of text in this font.\r\n   *\r\n   * @param text The text to be encoded.\r\n   * @returns The encoded text as a hex string.\r\n   */\r\n  encodeText(text: string): PDFHexString {\r\n    assertIs(text, 'text', ['string']);\r\n    this.modified = true;\r\n    return this.embedder.encodeText(text);\r\n  }\r\n\r\n  /**\r\n   * Measure the width of a string of text drawn in this font at a given size.\r\n   * For example:\r\n   * ```js\r\n   * const width = font.widthOfTextAtSize('Foo Bar Qux Baz', 36)\r\n   * ```\r\n   * @param text The string of text to be measured.\r\n   * @param size The font size to be used for this measurement.\r\n   * @returns The width of the string of text when drawn in this font at the\r\n   *          given size.\r\n   */\r\n  widthOfTextAtSize(text: string, size: number): number {\r\n    assertIs(text, 'text', ['string']);\r\n    assertIs(size, 'size', ['number']);\r\n    return this.embedder.widthOfTextAtSize(text, size);\r\n  }\r\n\r\n  /**\r\n   * Measure the height of this font at a given size. For example:\r\n   * ```js\r\n   * const height = font.heightAtSize(24)\r\n   * ```\r\n   *\r\n   * The `options.descender` value controls whether or not the font's\r\n   * descender is included in the height calculation.\r\n   *\r\n   * @param size The font size to be used for this measurement.\r\n   * @param options The options to be used when computing this measurement.\r\n   * @returns The height of this font at the given size.\r\n   */\r\n  heightAtSize(size: number, options?: { descender?: boolean }): number {\r\n    assertIs(size, 'size', ['number']);\r\n    assertOrUndefined(options?.descender, 'options.descender', ['boolean']);\r\n    return this.embedder.heightOfFontAtSize(size, {\r\n      descender: options?.descender ?? true,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compute the font size at which this font is a given height. For example:\r\n   * ```js\r\n   * const fontSize = font.sizeAtHeight(12)\r\n   * ```\r\n   * @param height The height to be used for this calculation.\r\n   * @returns The font size at which this font is the given height.\r\n   */\r\n  sizeAtHeight(height: number): number {\r\n    assertIs(height, 'height', ['number']);\r\n    return this.embedder.sizeOfFontAtHeight(height);\r\n  }\r\n\r\n  /**\r\n   * Get the set of unicode code points that can be represented by this font.\r\n   * @returns The set of unicode code points supported by this font.\r\n   */\r\n  getCharacterSet(): number[] {\r\n    if (this.embedder instanceof StandardFontEmbedder) {\r\n      return this.embedder.encoding.supportedCodePoints;\r\n    } else {\r\n      return this.embedder.font.characterSet;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * > **NOTE:** You probably don't need to call this method directly. The\r\n   * > [[PDFDocument.save]] and [[PDFDocument.saveAsBase64]] methods will\r\n   * > automatically ensure all fonts get embedded.\r\n   *\r\n   * Embed this font in its document.\r\n   *\r\n   * @returns Resolves when the embedding is complete.\r\n   */\r\n  async embed(): Promise<void> {\r\n    // TODO: Cleanup orphan embedded objects if a font is embedded multiple times...\r\n    if (this.modified) {\r\n      await this.embedder.embedIntoContext(this.doc.context, this.ref);\r\n      this.modified = false;\r\n    }\r\n  }\r\n}\r\n"],"mappings":";AACA,OAAOA,WAAW;AAClB,SACEC,kBAAkB,EAElBC,MAAM,EACNC,oBAAoB,QACrB;AACD,SAASC,QAAQ,EAAEC,iBAAiB,QAAE;AAItC;;;AAGA,IAAAC,OAAA;EA4BE,SAAAA,QAAoBC,GAAW,EAAEC,GAAgB,EAAEC,QAAsB;IAHjE,KAAAC,QAAQ,GAAG,IAAI;IAIrBN,QAAQ,CAACG,GAAG,EAAE,KAAK,EAAE,CAAC,CAACL,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC;IAC1CE,QAAQ,CAACI,GAAG,EAAE,KAAK,EAAE,CAAC,CAACR,WAAW,EAAE,aAAa,CAAC,CAAC,CAAC;IACpDI,QAAQ,CAACK,QAAQ,EAAE,UAAU,EAAE,CAC7B,CAACR,kBAAkB,EAAE,oBAAoB,CAAC,EAC1C,CAACE,oBAAoB,EAAE,sBAAsB,CAAC,CAC/C,CAAC;IAEF,IAAI,CAACI,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd,IAAI,CAACG,IAAI,GAAGF,QAAQ,CAACG,QAAQ;IAE7B,IAAI,CAACH,QAAQ,GAAGA,QAAQ;EAC1B;EAEA;;;;;;;;;;EAUAH,OAAA,CAAAO,SAAA,CAAAC,UAAU,GAAV,UAAWC,IAAY;IACrBX,QAAQ,CAACW,IAAI,EAAE,MAAM,EAAE,CAAC,QAAQ,CAAC,CAAC;IAClC,IAAI,CAACL,QAAQ,GAAG,IAAI;IACpB,OAAO,IAAI,CAACD,QAAQ,CAACK,UAAU,CAACC,IAAI,CAAC;EACvC,CAAC;EAED;;;;;;;;;;;EAWAT,OAAA,CAAAO,SAAA,CAAAG,iBAAiB,GAAjB,UAAkBD,IAAY,EAAEE,IAAY;IAC1Cb,QAAQ,CAACW,IAAI,EAAE,MAAM,EAAE,CAAC,QAAQ,CAAC,CAAC;IAClCX,QAAQ,CAACa,IAAI,EAAE,MAAM,EAAE,CAAC,QAAQ,CAAC,CAAC;IAClC,OAAO,IAAI,CAACR,QAAQ,CAACO,iBAAiB,CAACD,IAAI,EAAEE,IAAI,CAAC;EACpD,CAAC;EAED;;;;;;;;;;;;;EAaAX,OAAA,CAAAO,SAAA,CAAAK,YAAY,GAAZ,UAAaD,IAAY,EAAEE,OAAiC;;IAC1Df,QAAQ,CAACa,IAAI,EAAE,MAAM,EAAE,CAAC,QAAQ,CAAC,CAAC;IAClCZ,iBAAiB,CAACc,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEC,SAAS,EAAE,mBAAmB,EAAE,CAAC,SAAS,CAAC,CAAC;IACvE,OAAO,IAAI,CAACX,QAAQ,CAACY,kBAAkB,CAACJ,IAAI,EAAE;MAC5CG,SAAS,GAAAE,EAAA,GAAEH,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEC,SAAS,cAAAE,EAAA,cAAAA,EAAA,GAAI;KAClC,CAAC;EACJ,CAAC;EAED;;;;;;;;EAQAhB,OAAA,CAAAO,SAAA,CAAAU,YAAY,GAAZ,UAAaC,MAAc;IACzBpB,QAAQ,CAACoB,MAAM,EAAE,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC;IACtC,OAAO,IAAI,CAACf,QAAQ,CAACgB,kBAAkB,CAACD,MAAM,CAAC;EACjD,CAAC;EAED;;;;EAIAlB,OAAA,CAAAO,SAAA,CAAAa,eAAe,GAAf;IACE,IAAI,IAAI,CAACjB,QAAQ,YAAYN,oBAAoB,EAAE;MACjD,OAAO,IAAI,CAACM,QAAQ,CAACkB,QAAQ,CAACC,mBAAmB;KAClD,MAAM;MACL,OAAO,IAAI,CAACnB,QAAQ,CAACoB,IAAI,CAACC,YAAY;;EAE1C,CAAC;EAED;;;;;;;;;EASMxB,OAAA,CAAAO,SAAA,CAAAkB,KAAK,GAAX;;;;;iBAEM,IAAI,CAACrB,QAAQ,EAAb;YACF,qBAAM,IAAI,CAACD,QAAQ,CAACuB,gBAAgB,CAAC,IAAI,CAACxB,GAAG,CAACyB,OAAO,EAAE,IAAI,CAAC1B,GAAG,CAAC;;YAAhEe,EAAA,CAAAY,IAAA,EAAgE;YAChE,IAAI,CAACxB,QAAQ,GAAG,KAAK;;;;;;;GAExB;EAxID;;;;;;;;;;;;EAYOJ,OAAA,CAAA6B,EAAE,GAAG,UAAC5B,GAAW,EAAEC,GAAgB,EAAEC,QAAsB;IAChE,WAAIH,OAAO,CAACC,GAAG,EAAEC,GAAG,EAAEC,QAAQ,CAAC;EAA/B,CAA+B;EA4HnC,OAAAH,OAAC;CAAA,CA1ID;eAAqBA,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { PDFName, PDFArray, PDFDict, PDFHexString } from \"../core\";\n/**\r\n * Represents a file that has been embedded in a [[PDFDocument]].\r\n */\nvar PDFEmbeddedFile = /** @class */function () {\n  function PDFEmbeddedFile(ref, doc, embedder) {\n    this.alreadyEmbedded = false;\n    this.ref = ref;\n    this.doc = doc;\n    this.embedder = embedder;\n  }\n  /**\r\n   * > **NOTE:** You probably don't need to call this method directly. The\r\n   * > [[PDFDocument.save]] and [[PDFDocument.saveAsBase64]] methods will\r\n   * > automatically ensure all embeddable files get embedded.\r\n   *\r\n   * Embed this embeddable file in its document.\r\n   *\r\n   * @returns Resolves when the embedding is complete.\r\n   */\n  PDFEmbeddedFile.prototype.embed = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ref, Names, EmbeddedFiles, EFNames, AF;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!this.alreadyEmbedded) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.embedder.embedIntoContext(this.doc.context, this.ref)];\n          case 1:\n            ref = _a.sent();\n            if (!this.doc.catalog.has(PDFName.of('Names'))) {\n              this.doc.catalog.set(PDFName.of('Names'), this.doc.context.obj({}));\n            }\n            Names = this.doc.catalog.lookup(PDFName.of('Names'), PDFDict);\n            if (!Names.has(PDFName.of('EmbeddedFiles'))) {\n              Names.set(PDFName.of('EmbeddedFiles'), this.doc.context.obj({}));\n            }\n            EmbeddedFiles = Names.lookup(PDFName.of('EmbeddedFiles'), PDFDict);\n            if (!EmbeddedFiles.has(PDFName.of('Names'))) {\n              EmbeddedFiles.set(PDFName.of('Names'), this.doc.context.obj([]));\n            }\n            EFNames = EmbeddedFiles.lookup(PDFName.of('Names'), PDFArray);\n            EFNames.push(PDFHexString.fromText(this.embedder.fileName));\n            EFNames.push(ref);\n            /**\r\n             * The AF-Tag is needed to achieve PDF-A3 compliance for embedded files\r\n             *\r\n             * The following document outlines the uses cases of the associated files (AF) tag.\r\n             * See:\r\n             * https://www.pdfa.org/wp-content/uploads/2018/10/PDF20_AN002-AF.pdf\r\n             */\n            if (!this.doc.catalog.has(PDFName.of('AF'))) {\n              this.doc.catalog.set(PDFName.of('AF'), this.doc.context.obj([]));\n            }\n            AF = this.doc.catalog.lookup(PDFName.of('AF'), PDFArray);\n            AF.push(ref);\n            this.alreadyEmbedded = true;\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\r\n   * > consider using the [[PDFDocument.attach]] method, which will create\r\n   * instances of [[PDFEmbeddedFile]] for you.\r\n   *\r\n   * Create an instance of [[PDFEmbeddedFile]] from an existing ref and embedder\r\n   *\r\n   * @param ref The unique reference for this file.\r\n   * @param doc The document to which the file will belong.\r\n   * @param embedder The embedder that will be used to embed the file.\r\n   */\n  PDFEmbeddedFile.of = function (ref, doc, embedder) {\n    return new PDFEmbeddedFile(ref, doc, embedder);\n  };\n  return PDFEmbeddedFile;\n}();\nexport default PDFEmbeddedFile;","map":{"version":3,"names":["PDFName","PDFArray","PDFDict","PDFHexString","PDFEmbeddedFile","ref","doc","embedder","alreadyEmbedded","prototype","embed","embedIntoContext","context","_a","sent","catalog","has","of","set","obj","Names","lookup","EmbeddedFiles","EFNames","push","fromText","fileName","AF"],"sources":["C:\\Users\\TongNPZ\\Desktop\\my-app-2.0\\node_modules\\pdf-lib\\src\\api\\PDFEmbeddedFile.ts"],"sourcesContent":["import Embeddable from 'src/api/Embeddable';\r\nimport PDFDocument from 'src/api/PDFDocument';\r\nimport FileEmbedder from 'src/core/embedders/FileEmbedder';\r\nimport { PDFName, PDFArray, PDFDict, PDFHexString, PDFRef } from 'src/core';\r\n\r\n/**\r\n * Represents a file that has been embedded in a [[PDFDocument]].\r\n */\r\nexport default class PDFEmbeddedFile implements Embeddable {\r\n  /**\r\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\r\n   * > consider using the [[PDFDocument.attach]] method, which will create\r\n   * instances of [[PDFEmbeddedFile]] for you.\r\n   *\r\n   * Create an instance of [[PDFEmbeddedFile]] from an existing ref and embedder\r\n   *\r\n   * @param ref The unique reference for this file.\r\n   * @param doc The document to which the file will belong.\r\n   * @param embedder The embedder that will be used to embed the file.\r\n   */\r\n  static of = (ref: PDFRef, doc: PDFDocument, embedder: FileEmbedder) =>\r\n    new PDFEmbeddedFile(ref, doc, embedder);\r\n\r\n  /** The unique reference assigned to this embedded file within the document. */\r\n  readonly ref: PDFRef;\r\n\r\n  /** The document to which this embedded file belongs. */\r\n  readonly doc: PDFDocument;\r\n\r\n  private alreadyEmbedded = false;\r\n  private readonly embedder: FileEmbedder;\r\n\r\n  private constructor(ref: PDFRef, doc: PDFDocument, embedder: FileEmbedder) {\r\n    this.ref = ref;\r\n    this.doc = doc;\r\n    this.embedder = embedder;\r\n  }\r\n\r\n  /**\r\n   * > **NOTE:** You probably don't need to call this method directly. The\r\n   * > [[PDFDocument.save]] and [[PDFDocument.saveAsBase64]] methods will\r\n   * > automatically ensure all embeddable files get embedded.\r\n   *\r\n   * Embed this embeddable file in its document.\r\n   *\r\n   * @returns Resolves when the embedding is complete.\r\n   */\r\n  async embed(): Promise<void> {\r\n    if (!this.alreadyEmbedded) {\r\n      const ref = await this.embedder.embedIntoContext(\r\n        this.doc.context,\r\n        this.ref,\r\n      );\r\n\r\n      if (!this.doc.catalog.has(PDFName.of('Names'))) {\r\n        this.doc.catalog.set(PDFName.of('Names'), this.doc.context.obj({}));\r\n      }\r\n      const Names = this.doc.catalog.lookup(PDFName.of('Names'), PDFDict);\r\n\r\n      if (!Names.has(PDFName.of('EmbeddedFiles'))) {\r\n        Names.set(PDFName.of('EmbeddedFiles'), this.doc.context.obj({}));\r\n      }\r\n      const EmbeddedFiles = Names.lookup(PDFName.of('EmbeddedFiles'), PDFDict);\r\n\r\n      if (!EmbeddedFiles.has(PDFName.of('Names'))) {\r\n        EmbeddedFiles.set(PDFName.of('Names'), this.doc.context.obj([]));\r\n      }\r\n      const EFNames = EmbeddedFiles.lookup(PDFName.of('Names'), PDFArray);\r\n\r\n      EFNames.push(PDFHexString.fromText(this.embedder.fileName));\r\n      EFNames.push(ref);\r\n\r\n      /**\r\n       * The AF-Tag is needed to achieve PDF-A3 compliance for embedded files\r\n       *\r\n       * The following document outlines the uses cases of the associated files (AF) tag.\r\n       * See:\r\n       * https://www.pdfa.org/wp-content/uploads/2018/10/PDF20_AN002-AF.pdf\r\n       */\r\n\r\n      if (!this.doc.catalog.has(PDFName.of('AF'))) {\r\n        this.doc.catalog.set(PDFName.of('AF'), this.doc.context.obj([]));\r\n      }\r\n      const AF = this.doc.catalog.lookup(PDFName.of('AF'), PDFArray);\r\n      AF.push(ref);\r\n\r\n      this.alreadyEmbedded = true;\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
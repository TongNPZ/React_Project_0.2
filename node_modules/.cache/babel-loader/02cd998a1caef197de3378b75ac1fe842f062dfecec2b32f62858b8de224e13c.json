{"ast":null,"code":"export var toCharCode = function (character) {\n  return character.charCodeAt(0);\n};\nexport var toCodePoint = function (character) {\n  return character.codePointAt(0);\n};\nexport var toHexStringOfMinLength = function (num, minLength) {\n  return padStart(num.toString(16), minLength, '0').toUpperCase();\n};\nexport var toHexString = function (num) {\n  return toHexStringOfMinLength(num, 2);\n};\nexport var charFromCode = function (code) {\n  return String.fromCharCode(code);\n};\nexport var charFromHexCode = function (hex) {\n  return charFromCode(parseInt(hex, 16));\n};\nexport var padStart = function (value, length, padChar) {\n  var padding = '';\n  for (var idx = 0, len = length - value.length; idx < len; idx++) {\n    padding += padChar;\n  }\n  return padding + value;\n};\nexport var copyStringIntoBuffer = function (str, buffer, offset) {\n  var length = str.length;\n  for (var idx = 0; idx < length; idx++) {\n    buffer[offset++] = str.charCodeAt(idx);\n  }\n  return length;\n};\nexport var addRandomSuffix = function (prefix, suffixLength) {\n  if (suffixLength === void 0) {\n    suffixLength = 4;\n  }\n  return prefix + \"-\" + Math.floor(Math.random() * Math.pow(10, suffixLength));\n};\nexport var escapeRegExp = function (str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\nexport var cleanText = function (text) {\n  return text.replace(/\\t|\\u0085|\\u2028|\\u2029/g, '    ').replace(/[\\b\\v]/g, '');\n};\nexport var escapedNewlineChars = ['\\\\n', '\\\\f', '\\\\r', '\\\\u000B'];\nexport var newlineChars = ['\\n', '\\f', '\\r', '\\u000B'];\nexport var isNewlineChar = function (text) {\n  return /^[\\n\\f\\r\\u000B]$/.test(text);\n};\nexport var lineSplit = function (text) {\n  return text.split(/[\\n\\f\\r\\u000B]/);\n};\nexport var mergeLines = function (text) {\n  return text.replace(/[\\n\\f\\r\\u000B]/g, ' ');\n};\n// JavaScript's String.charAt() method doesn work on strings containing UTF-16\n// characters (with high and low surrogate pairs), such as ðŸ’© (poo emoji). This\n// `charAtIndex()` function does.\n//\n// Credit: https://github.com/mathiasbynens/String.prototype.at/blob/master/at.js#L14-L48\nexport var charAtIndex = function (text, index) {\n  // Get the first code unit and code unit value\n  var cuFirst = text.charCodeAt(index);\n  var cuSecond;\n  var nextIndex = index + 1;\n  var length = 1;\n  if (\n  // Check if it's the start of a surrogate pair.\n  cuFirst >= 0xd800 && cuFirst <= 0xdbff &&\n  // high surrogate\n  text.length > nextIndex // there is a next code unit\n  ) {\n    cuSecond = text.charCodeAt(nextIndex);\n    if (cuSecond >= 0xdc00 && cuSecond <= 0xdfff) length = 2; // low surrogate\n  }\n\n  return [text.slice(index, index + length), length];\n};\nexport var charSplit = function (text) {\n  var chars = [];\n  for (var idx = 0, len = text.length; idx < len;) {\n    var _a = charAtIndex(text, idx),\n      c = _a[0],\n      cLen = _a[1];\n    chars.push(c);\n    idx += cLen;\n  }\n  return chars;\n};\nvar buildWordBreakRegex = function (wordBreaks) {\n  var newlineCharUnion = escapedNewlineChars.join('|');\n  var escapedRules = ['$'];\n  for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {\n    var wordBreak = wordBreaks[idx];\n    if (isNewlineChar(wordBreak)) {\n      throw new TypeError(\"`wordBreak` must not include \" + newlineCharUnion);\n    }\n    escapedRules.push(wordBreak === '' ? '.' : escapeRegExp(wordBreak));\n  }\n  var breakRules = escapedRules.join('|');\n  return new RegExp(\"(\" + newlineCharUnion + \")|((.*?)(\" + breakRules + \"))\", 'gm');\n};\nexport var breakTextIntoLines = function (text, wordBreaks, maxWidth, computeWidthOfText) {\n  var regex = buildWordBreakRegex(wordBreaks);\n  var words = cleanText(text).match(regex);\n  var currLine = '';\n  var currWidth = 0;\n  var lines = [];\n  var pushCurrLine = function () {\n    if (currLine !== '') lines.push(currLine);\n    currLine = '';\n    currWidth = 0;\n  };\n  for (var idx = 0, len = words.length; idx < len; idx++) {\n    var word = words[idx];\n    if (isNewlineChar(word)) {\n      pushCurrLine();\n    } else {\n      var width = computeWidthOfText(word);\n      if (currWidth + width > maxWidth) pushCurrLine();\n      currLine += word;\n      currWidth += width;\n    }\n  }\n  pushCurrLine();\n  return lines;\n};\n// See section \"7.9.4 Dates\" of the PDF specification\nvar dateRegex = /^D:(\\d\\d\\d\\d)(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?([+\\-Z])?(\\d\\d)?'?(\\d\\d)?'?$/;\nexport var parseDate = function (dateStr) {\n  var match = dateStr.match(dateRegex);\n  if (!match) return undefined;\n  var year = match[1],\n    _a = match[2],\n    month = _a === void 0 ? '01' : _a,\n    _b = match[3],\n    day = _b === void 0 ? '01' : _b,\n    _c = match[4],\n    hours = _c === void 0 ? '00' : _c,\n    _d = match[5],\n    mins = _d === void 0 ? '00' : _d,\n    _e = match[6],\n    secs = _e === void 0 ? '00' : _e,\n    _f = match[7],\n    offsetSign = _f === void 0 ? 'Z' : _f,\n    _g = match[8],\n    offsetHours = _g === void 0 ? '00' : _g,\n    _h = match[9],\n    offsetMins = _h === void 0 ? '00' : _h;\n  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n  var tzOffset = offsetSign === 'Z' ? 'Z' : \"\" + offsetSign + offsetHours + \":\" + offsetMins;\n  var date = new Date(year + \"-\" + month + \"-\" + day + \"T\" + hours + \":\" + mins + \":\" + secs + tzOffset);\n  return date;\n};\nexport var findLastMatch = function (value, regex) {\n  var _a;\n  var position = 0;\n  var lastMatch;\n  while (position < value.length) {\n    var match = value.substring(position).match(regex);\n    if (!match) return {\n      match: lastMatch,\n      pos: position\n    };\n    lastMatch = match;\n    position += ((_a = match.index) !== null && _a !== void 0 ? _a : 0) + match[0].length;\n  }\n  return {\n    match: lastMatch,\n    pos: position\n  };\n};","map":{"version":3,"names":["toCharCode","character","charCodeAt","toCodePoint","codePointAt","toHexStringOfMinLength","num","minLength","padStart","toString","toUpperCase","toHexString","charFromCode","code","String","fromCharCode","charFromHexCode","hex","parseInt","value","length","padChar","padding","idx","len","copyStringIntoBuffer","str","buffer","offset","addRandomSuffix","prefix","suffixLength","Math","floor","random","pow","escapeRegExp","replace","cleanText","text","escapedNewlineChars","newlineChars","isNewlineChar","test","lineSplit","split","mergeLines","charAtIndex","index","cuFirst","cuSecond","nextIndex","slice","charSplit","chars","_a","c","cLen","push","buildWordBreakRegex","wordBreaks","newlineCharUnion","join","escapedRules","wordBreak","TypeError","breakRules","RegExp","breakTextIntoLines","maxWidth","computeWidthOfText","regex","words","match","currLine","currWidth","lines","pushCurrLine","word","width","dateRegex","parseDate","dateStr","undefined","year","month","_b","day","_c","hours","_d","mins","_e","secs","_f","offsetSign","_g","offsetHours","_h","offsetMins","tzOffset","date","Date","findLastMatch","position","lastMatch","substring","pos"],"sources":["C:\\Users\\TongNPZ\\Desktop\\my-app-2.0 - Copy (2)\\node_modules\\pdf-lib\\src\\utils\\strings.ts"],"sourcesContent":["export const toCharCode = (character: string) => character.charCodeAt(0);\r\n\r\nexport const toCodePoint = (character: string) => character.codePointAt(0);\r\n\r\nexport const toHexStringOfMinLength = (num: number, minLength: number) =>\r\n  padStart(num.toString(16), minLength, '0').toUpperCase();\r\n\r\nexport const toHexString = (num: number) => toHexStringOfMinLength(num, 2);\r\n\r\nexport const charFromCode = (code: number) => String.fromCharCode(code);\r\n\r\nexport const charFromHexCode = (hex: string) => charFromCode(parseInt(hex, 16));\r\n\r\nexport const padStart = (value: string, length: number, padChar: string) => {\r\n  let padding = '';\r\n  for (let idx = 0, len = length - value.length; idx < len; idx++) {\r\n    padding += padChar;\r\n  }\r\n  return padding + value;\r\n};\r\n\r\nexport const copyStringIntoBuffer = (\r\n  str: string,\r\n  buffer: Uint8Array,\r\n  offset: number,\r\n): number => {\r\n  const length = str.length;\r\n  for (let idx = 0; idx < length; idx++) {\r\n    buffer[offset++] = str.charCodeAt(idx);\r\n  }\r\n  return length;\r\n};\r\n\r\nexport const addRandomSuffix = (prefix: string, suffixLength = 4) =>\r\n  `${prefix}-${Math.floor(Math.random() * 10 ** suffixLength)}`;\r\n\r\nexport const escapeRegExp = (str: string) =>\r\n  str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n\r\nexport const cleanText = (text: string) =>\r\n  text.replace(/\\t|\\u0085|\\u2028|\\u2029/g, '    ').replace(/[\\b\\v]/g, '');\r\n\r\nexport const escapedNewlineChars = ['\\\\n', '\\\\f', '\\\\r', '\\\\u000B'];\r\n\r\nexport const newlineChars = ['\\n', '\\f', '\\r', '\\u000B'];\r\n\r\nexport const isNewlineChar = (text: string) => /^[\\n\\f\\r\\u000B]$/.test(text);\r\n\r\nexport const lineSplit = (text: string) => text.split(/[\\n\\f\\r\\u000B]/);\r\n\r\nexport const mergeLines = (text: string) =>\r\n  text.replace(/[\\n\\f\\r\\u000B]/g, ' ');\r\n\r\n// JavaScript's String.charAt() method doesn work on strings containing UTF-16\r\n// characters (with high and low surrogate pairs), such as ðŸ’© (poo emoji). This\r\n// `charAtIndex()` function does.\r\n//\r\n// Credit: https://github.com/mathiasbynens/String.prototype.at/blob/master/at.js#L14-L48\r\nexport const charAtIndex = (text: string, index: number): [string, number] => {\r\n  // Get the first code unit and code unit value\r\n  const cuFirst = text.charCodeAt(index);\r\n  let cuSecond: number;\r\n  const nextIndex = index + 1;\r\n  let length = 1;\r\n  if (\r\n    // Check if it's the start of a surrogate pair.\r\n    cuFirst >= 0xd800 &&\r\n    cuFirst <= 0xdbff && // high surrogate\r\n    text.length > nextIndex // there is a next code unit\r\n  ) {\r\n    cuSecond = text.charCodeAt(nextIndex);\r\n    if (cuSecond >= 0xdc00 && cuSecond <= 0xdfff) length = 2; // low surrogate\r\n  }\r\n  return [text.slice(index, index + length), length];\r\n};\r\n\r\nexport const charSplit = (text: string) => {\r\n  const chars: string[] = [];\r\n\r\n  for (let idx = 0, len = text.length; idx < len; ) {\r\n    const [c, cLen] = charAtIndex(text, idx);\r\n    chars.push(c);\r\n    idx += cLen;\r\n  }\r\n\r\n  return chars;\r\n};\r\n\r\nconst buildWordBreakRegex = (wordBreaks: string[]) => {\r\n  const newlineCharUnion = escapedNewlineChars.join('|');\r\n\r\n  const escapedRules: string[] = ['$'];\r\n  for (let idx = 0, len = wordBreaks.length; idx < len; idx++) {\r\n    const wordBreak = wordBreaks[idx];\r\n    if (isNewlineChar(wordBreak)) {\r\n      throw new TypeError(`\\`wordBreak\\` must not include ${newlineCharUnion}`);\r\n    }\r\n    escapedRules.push(wordBreak === '' ? '.' : escapeRegExp(wordBreak));\r\n  }\r\n\r\n  const breakRules = escapedRules.join('|');\r\n  return new RegExp(`(${newlineCharUnion})|((.*?)(${breakRules}))`, 'gm');\r\n};\r\n\r\nexport const breakTextIntoLines = (\r\n  text: string,\r\n  wordBreaks: string[],\r\n  maxWidth: number,\r\n  computeWidthOfText: (t: string) => number,\r\n): string[] => {\r\n  const regex = buildWordBreakRegex(wordBreaks);\r\n\r\n  const words = cleanText(text).match(regex)!;\r\n\r\n  let currLine = '';\r\n  let currWidth = 0;\r\n  const lines: string[] = [];\r\n\r\n  const pushCurrLine = () => {\r\n    if (currLine !== '') lines.push(currLine);\r\n    currLine = '';\r\n    currWidth = 0;\r\n  };\r\n\r\n  for (let idx = 0, len = words.length; idx < len; idx++) {\r\n    const word = words[idx];\r\n    if (isNewlineChar(word)) {\r\n      pushCurrLine();\r\n    } else {\r\n      const width = computeWidthOfText(word);\r\n      if (currWidth + width > maxWidth) pushCurrLine();\r\n      currLine += word;\r\n      currWidth += width;\r\n    }\r\n  }\r\n  pushCurrLine();\r\n\r\n  return lines;\r\n};\r\n\r\n// See section \"7.9.4 Dates\" of the PDF specification\r\nconst dateRegex = /^D:(\\d\\d\\d\\d)(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?([+\\-Z])?(\\d\\d)?'?(\\d\\d)?'?$/;\r\n\r\nexport const parseDate = (dateStr: string): Date | undefined => {\r\n  const match = dateStr.match(dateRegex);\r\n\r\n  if (!match) return undefined;\r\n\r\n  const [\r\n    ,\r\n    year,\r\n    month = '01',\r\n    day = '01',\r\n    hours = '00',\r\n    mins = '00',\r\n    secs = '00',\r\n    offsetSign = 'Z',\r\n    offsetHours = '00',\r\n    offsetMins = '00',\r\n  ] = match;\r\n\r\n  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\r\n  const tzOffset =\r\n    offsetSign === 'Z' ? 'Z' : `${offsetSign}${offsetHours}:${offsetMins}`;\r\n  const date = new Date(\r\n    `${year}-${month}-${day}T${hours}:${mins}:${secs}${tzOffset}`,\r\n  );\r\n\r\n  return date;\r\n};\r\n\r\nexport const findLastMatch = (value: string, regex: RegExp) => {\r\n  let position = 0;\r\n  let lastMatch: RegExpMatchArray | undefined;\r\n  while (position < value.length) {\r\n    const match = value.substring(position).match(regex);\r\n    if (!match) return { match: lastMatch, pos: position };\r\n    lastMatch = match;\r\n    position += (match.index ?? 0) + match[0].length;\r\n  }\r\n  return { match: lastMatch, pos: position };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport PDFTrailerDict from \"../document/PDFTrailerDict\";\nimport PDFObjectStream from \"../structures/PDFObjectStream\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, waitForTick } from \"../../utils\";\nvar PDFWriter = /** @class */function () {\n  function PDFWriter(context, objectsPerTick) {\n    var _this = this;\n    this.parsedObjects = 0;\n    this.shouldWaitForTick = function (n) {\n      _this.parsedObjects += n;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n    this.context = context;\n    this.objectsPerTick = objectsPerTick;\n  }\n  PDFWriter.prototype.serializeToBuffer = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset, buffer, idx, len, _b, ref, object, objectNumber, generationNumber, n;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4 /*yield*/, this.computeBufferSize()];\n          case 1:\n            _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;\n            offset = 0;\n            buffer = new Uint8Array(size);\n            offset += header.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.Newline;\n            idx = 0, len = indirectObjects.length;\n            _c.label = 2;\n          case 2:\n            if (!(idx < len)) return [3 /*break*/, 5];\n            _b = indirectObjects[idx], ref = _b[0], object = _b[1];\n            objectNumber = String(ref.objectNumber);\n            offset += copyStringIntoBuffer(objectNumber, buffer, offset);\n            buffer[offset++] = CharCodes.Space;\n            generationNumber = String(ref.generationNumber);\n            offset += copyStringIntoBuffer(generationNumber, buffer, offset);\n            buffer[offset++] = CharCodes.Space;\n            buffer[offset++] = CharCodes.o;\n            buffer[offset++] = CharCodes.b;\n            buffer[offset++] = CharCodes.j;\n            buffer[offset++] = CharCodes.Newline;\n            offset += object.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.e;\n            buffer[offset++] = CharCodes.n;\n            buffer[offset++] = CharCodes.d;\n            buffer[offset++] = CharCodes.o;\n            buffer[offset++] = CharCodes.b;\n            buffer[offset++] = CharCodes.j;\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.Newline;\n            n = object instanceof PDFObjectStream ? object.getObjectsCount() : 1;\n            if (!this.shouldWaitForTick(n)) return [3 /*break*/, 4];\n            return [4 /*yield*/, waitForTick()];\n          case 3:\n            _c.sent();\n            _c.label = 4;\n          case 4:\n            idx++;\n            return [3 /*break*/, 2];\n          case 5:\n            if (xref) {\n              offset += xref.copyBytesInto(buffer, offset);\n              buffer[offset++] = CharCodes.Newline;\n            }\n            if (trailerDict) {\n              offset += trailerDict.copyBytesInto(buffer, offset);\n              buffer[offset++] = CharCodes.Newline;\n              buffer[offset++] = CharCodes.Newline;\n            }\n            offset += trailer.copyBytesInto(buffer, offset);\n            return [2 /*return*/, buffer];\n        }\n      });\n    });\n  };\n  PDFWriter.prototype.computeIndirectObjectSize = function (_a) {\n    var ref = _a[0],\n      object = _a[1];\n    var refSize = ref.sizeInBytes() + 3; // 'R' -> 'obj\\n'\n    var objectSize = object.sizeInBytes() + 9; // '\\nendobj\\n\\n'\n    return refSize + objectSize;\n  };\n  PDFWriter.prototype.createTrailerDict = function () {\n    return this.context.obj({\n      Size: this.context.largestObjectNumber + 1,\n      Root: this.context.trailerInfo.Root,\n      Encrypt: this.context.trailerInfo.Encrypt,\n      Info: this.context.trailerInfo.Info,\n      ID: this.context.trailerInfo.ID\n    });\n  };\n  PDFWriter.prototype.computeBufferSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            header = PDFHeader.forVersion(1, 7);\n            size = header.sizeInBytes() + 2;\n            xref = PDFCrossRefSection.create();\n            indirectObjects = this.context.enumerateIndirectObjects();\n            idx = 0, len = indirectObjects.length;\n            _a.label = 1;\n          case 1:\n            if (!(idx < len)) return [3 /*break*/, 4];\n            indirectObject = indirectObjects[idx];\n            ref = indirectObject[0];\n            xref.addEntry(ref, size);\n            size += this.computeIndirectObjectSize(indirectObject);\n            if (!this.shouldWaitForTick(1)) return [3 /*break*/, 3];\n            return [4 /*yield*/, waitForTick()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            idx++;\n            return [3 /*break*/, 1];\n          case 4:\n            xrefOffset = size;\n            size += xref.sizeInBytes() + 1; // '\\n'\n            trailerDict = PDFTrailerDict.of(this.createTrailerDict());\n            size += trailerDict.sizeInBytes() + 2; // '\\n\\n'\n            trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\n            size += trailer.sizeInBytes();\n            return [2 /*return*/, {\n              size: size,\n              header: header,\n              indirectObjects: indirectObjects,\n              xref: xref,\n              trailerDict: trailerDict,\n              trailer: trailer\n            }];\n        }\n      });\n    });\n  };\n  PDFWriter.forContext = function (context, objectsPerTick) {\n    return new PDFWriter(context, objectsPerTick);\n  };\n  return PDFWriter;\n}();\nexport default PDFWriter;","map":{"version":3,"names":["PDFCrossRefSection","PDFHeader","PDFTrailer","PDFTrailerDict","PDFObjectStream","CharCodes","copyStringIntoBuffer","waitForTick","PDFWriter","context","objectsPerTick","_this","parsedObjects","shouldWaitForTick","n","prototype","serializeToBuffer","computeBufferSize","_a","_c","sent","size","header","indirectObjects","xref","trailerDict","trailer","offset","buffer","Uint8Array","copyBytesInto","Newline","idx","len","length","_b","ref","object","objectNumber","String","Space","generationNumber","o","b","j","e","d","getObjectsCount","computeIndirectObjectSize","refSize","sizeInBytes","objectSize","createTrailerDict","obj","Size","largestObjectNumber","Root","trailerInfo","Encrypt","Info","ID","forVersion","create","enumerateIndirectObjects","indirectObject","addEntry","xrefOffset","of","forLastCrossRefSectionOffset","forContext"],"sources":["C:\\Users\\TongNPZ\\Desktop\\my-app-2.0\\node_modules\\pdf-lib\\src\\core\\writers\\PDFWriter.ts"],"sourcesContent":["import PDFCrossRefSection from 'src/core/document/PDFCrossRefSection';\r\nimport PDFHeader from 'src/core/document/PDFHeader';\r\nimport PDFTrailer from 'src/core/document/PDFTrailer';\r\nimport PDFTrailerDict from 'src/core/document/PDFTrailerDict';\r\nimport PDFDict from 'src/core/objects/PDFDict';\r\nimport PDFObject from 'src/core/objects/PDFObject';\r\nimport PDFRef from 'src/core/objects/PDFRef';\r\nimport PDFContext from 'src/core/PDFContext';\r\nimport PDFObjectStream from 'src/core/structures/PDFObjectStream';\r\nimport CharCodes from 'src/core/syntax/CharCodes';\r\nimport { copyStringIntoBuffer, waitForTick } from 'src/utils';\r\n\r\nexport interface SerializationInfo {\r\n  size: number;\r\n  header: PDFHeader;\r\n  indirectObjects: [PDFRef, PDFObject][];\r\n  xref?: PDFCrossRefSection;\r\n  trailerDict?: PDFTrailerDict;\r\n  trailer: PDFTrailer;\r\n}\r\n\r\nclass PDFWriter {\r\n  static forContext = (context: PDFContext, objectsPerTick: number) =>\r\n    new PDFWriter(context, objectsPerTick);\r\n\r\n  protected readonly context: PDFContext;\r\n\r\n  protected readonly objectsPerTick: number;\r\n  private parsedObjects = 0;\r\n\r\n  protected constructor(context: PDFContext, objectsPerTick: number) {\r\n    this.context = context;\r\n    this.objectsPerTick = objectsPerTick;\r\n  }\r\n\r\n  async serializeToBuffer(): Promise<Uint8Array> {\r\n    const {\r\n      size,\r\n      header,\r\n      indirectObjects,\r\n      xref,\r\n      trailerDict,\r\n      trailer,\r\n    } = await this.computeBufferSize();\r\n\r\n    let offset = 0;\r\n    const buffer = new Uint8Array(size);\r\n\r\n    offset += header.copyBytesInto(buffer, offset);\r\n    buffer[offset++] = CharCodes.Newline;\r\n    buffer[offset++] = CharCodes.Newline;\r\n\r\n    for (let idx = 0, len = indirectObjects.length; idx < len; idx++) {\r\n      const [ref, object] = indirectObjects[idx];\r\n\r\n      const objectNumber = String(ref.objectNumber);\r\n      offset += copyStringIntoBuffer(objectNumber, buffer, offset);\r\n      buffer[offset++] = CharCodes.Space;\r\n\r\n      const generationNumber = String(ref.generationNumber);\r\n      offset += copyStringIntoBuffer(generationNumber, buffer, offset);\r\n      buffer[offset++] = CharCodes.Space;\r\n\r\n      buffer[offset++] = CharCodes.o;\r\n      buffer[offset++] = CharCodes.b;\r\n      buffer[offset++] = CharCodes.j;\r\n      buffer[offset++] = CharCodes.Newline;\r\n\r\n      offset += object.copyBytesInto(buffer, offset);\r\n\r\n      buffer[offset++] = CharCodes.Newline;\r\n      buffer[offset++] = CharCodes.e;\r\n      buffer[offset++] = CharCodes.n;\r\n      buffer[offset++] = CharCodes.d;\r\n      buffer[offset++] = CharCodes.o;\r\n      buffer[offset++] = CharCodes.b;\r\n      buffer[offset++] = CharCodes.j;\r\n      buffer[offset++] = CharCodes.Newline;\r\n      buffer[offset++] = CharCodes.Newline;\r\n\r\n      const n =\r\n        object instanceof PDFObjectStream ? object.getObjectsCount() : 1;\r\n      if (this.shouldWaitForTick(n)) await waitForTick();\r\n    }\r\n\r\n    if (xref) {\r\n      offset += xref.copyBytesInto(buffer, offset);\r\n      buffer[offset++] = CharCodes.Newline;\r\n    }\r\n\r\n    if (trailerDict) {\r\n      offset += trailerDict.copyBytesInto(buffer, offset);\r\n      buffer[offset++] = CharCodes.Newline;\r\n      buffer[offset++] = CharCodes.Newline;\r\n    }\r\n\r\n    offset += trailer.copyBytesInto(buffer, offset);\r\n\r\n    return buffer;\r\n  }\r\n\r\n  protected computeIndirectObjectSize([ref, object]: [\r\n    PDFRef,\r\n    PDFObject,\r\n  ]): number {\r\n    const refSize = ref.sizeInBytes() + 3; // 'R' -> 'obj\\n'\r\n    const objectSize = object.sizeInBytes() + 9; // '\\nendobj\\n\\n'\r\n    return refSize + objectSize;\r\n  }\r\n\r\n  protected createTrailerDict(): PDFDict {\r\n    return this.context.obj({\r\n      Size: this.context.largestObjectNumber + 1,\r\n      Root: this.context.trailerInfo.Root,\r\n      Encrypt: this.context.trailerInfo.Encrypt,\r\n      Info: this.context.trailerInfo.Info,\r\n      ID: this.context.trailerInfo.ID,\r\n    });\r\n  }\r\n\r\n  protected async computeBufferSize(): Promise<SerializationInfo> {\r\n    const header = PDFHeader.forVersion(1, 7);\r\n\r\n    let size = header.sizeInBytes() + 2;\r\n\r\n    const xref = PDFCrossRefSection.create();\r\n\r\n    const indirectObjects = this.context.enumerateIndirectObjects();\r\n\r\n    for (let idx = 0, len = indirectObjects.length; idx < len; idx++) {\r\n      const indirectObject = indirectObjects[idx];\r\n      const [ref] = indirectObject;\r\n      xref.addEntry(ref, size);\r\n      size += this.computeIndirectObjectSize(indirectObject);\r\n      if (this.shouldWaitForTick(1)) await waitForTick();\r\n    }\r\n\r\n    const xrefOffset = size;\r\n    size += xref.sizeInBytes() + 1; // '\\n'\r\n\r\n    const trailerDict = PDFTrailerDict.of(this.createTrailerDict());\r\n    size += trailerDict.sizeInBytes() + 2; // '\\n\\n'\r\n\r\n    const trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\r\n    size += trailer.sizeInBytes();\r\n\r\n    return { size, header, indirectObjects, xref, trailerDict, trailer };\r\n  }\r\n\r\n  protected shouldWaitForTick = (n: number) => {\r\n    this.parsedObjects += n;\r\n    return this.parsedObjects % this.objectsPerTick === 0;\r\n  };\r\n}\r\n\r\nexport default PDFWriter;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFPageLeaf from \"./PDFPageLeaf\";\nimport { InvalidTargetIndexError, CorruptPageTreeError } from \"../errors\";\nvar PDFPageTree = /** @class */function (_super) {\n  __extends(PDFPageTree, _super);\n  function PDFPageTree() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PDFPageTree.prototype.Parent = function () {\n    return this.lookup(PDFName.of('Parent'));\n  };\n  PDFPageTree.prototype.Kids = function () {\n    return this.lookup(PDFName.of('Kids'), PDFArray);\n  };\n  PDFPageTree.prototype.Count = function () {\n    return this.lookup(PDFName.of('Count'), PDFNumber);\n  };\n  PDFPageTree.prototype.pushTreeNode = function (treeRef) {\n    var Kids = this.Kids();\n    Kids.push(treeRef);\n  };\n  PDFPageTree.prototype.pushLeafNode = function (leafRef) {\n    var Kids = this.Kids();\n    this.insertLeafKid(Kids.size(), leafRef);\n  };\n  /**\r\n   * Inserts the given ref as a leaf node of this page tree at the specified\r\n   * index (zero-based). Also increments the `Count` of each page tree in the\r\n   * hierarchy to accomodate the new page.\r\n   *\r\n   * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\r\n   * or `undefined` if it was inserted into the root node (the PDFPageTree upon\r\n   * which the method was first called).\r\n   */\n  PDFPageTree.prototype.insertLeafNode = function (leafRef, targetIndex) {\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex > Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      if (leafsRemainingUntilTarget === 0) {\n        // Insert page and return\n        this.insertLeafKid(idx, leafRef);\n        return undefined;\n      }\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf) {\n        // Move on\n        leafsRemainingUntilTarget -= 1;\n      }\n    }\n    if (leafsRemainingUntilTarget === 0) {\n      // Insert page at the end and return\n      this.insertLeafKid(Kids.size(), leafRef);\n      return undefined;\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\n  };\n  /**\r\n   * Removes the leaf node at the specified index (zero-based) from this page\r\n   * tree. Also decrements the `Count` of each page tree in the hierarchy to\r\n   * account for the removed page.\r\n   *\r\n   * If `prune` is true, then intermediate tree nodes will be removed from the\r\n   * tree if they contain 0 children after the leaf node is removed.\r\n   */\n  PDFPageTree.prototype.removeLeafNode = function (targetIndex, prune) {\n    if (prune === void 0) {\n      prune = true;\n    }\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex >= Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          kid.removeLeafNode(leafsRemainingUntilTarget, prune);\n          if (prune && kid.Kids().size() === 0) Kids.remove(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf) {\n        if (leafsRemainingUntilTarget === 0) {\n          // Remove page and return\n          this.removeKid(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= 1;\n        }\n      }\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\n  };\n  PDFPageTree.prototype.ascend = function (visitor) {\n    visitor(this);\n    var Parent = this.Parent();\n    if (Parent) Parent.ascend(visitor);\n  };\n  /** Performs a Post-Order traversal of this page tree */\n  PDFPageTree.prototype.traverse = function (visitor) {\n    var Kids = this.Kids();\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) kid.traverse(visitor);\n      visitor(kid, kidRef);\n    }\n  };\n  PDFPageTree.prototype.insertLeafKid = function (kidIdx, leafRef) {\n    var Kids = this.Kids();\n    this.ascend(function (node) {\n      var newCount = node.Count().asNumber() + 1;\n      node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n    });\n    Kids.insert(kidIdx, leafRef);\n  };\n  PDFPageTree.prototype.removeKid = function (kidIdx) {\n    var Kids = this.Kids();\n    var kid = Kids.lookup(kidIdx);\n    if (kid instanceof PDFPageLeaf) {\n      this.ascend(function (node) {\n        var newCount = node.Count().asNumber() - 1;\n        node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n      });\n    }\n    Kids.remove(kidIdx);\n  };\n  PDFPageTree.withContext = function (context, parent) {\n    var dict = new Map();\n    dict.set(PDFName.of('Type'), PDFName.of('Pages'));\n    dict.set(PDFName.of('Kids'), context.obj([]));\n    dict.set(PDFName.of('Count'), context.obj(0));\n    if (parent) dict.set(PDFName.of('Parent'), parent);\n    return new PDFPageTree(dict, context);\n  };\n  PDFPageTree.fromMapWithContext = function (map, context) {\n    return new PDFPageTree(map, context);\n  };\n  return PDFPageTree;\n}(PDFDict);\nexport default PDFPageTree;","map":{"version":3,"names":["PDFArray","PDFDict","PDFName","PDFNumber","PDFPageLeaf","InvalidTargetIndexError","CorruptPageTreeError","PDFPageTree","_super","__extends","prototype","Parent","lookup","of","Kids","Count","pushTreeNode","treeRef","push","pushLeafNode","leafRef","insertLeafKid","size","insertLeafNode","targetIndex","asNumber","leafsRemainingUntilTarget","idx","len","undefined","kidRef","get","kid","context","removeLeafNode","prune","remove","removeKid","ascend","visitor","traverse","kidIdx","node","newCount","set","insert","withContext","parent","dict","Map","obj","fromMapWithContext","map"],"sources":["C:\\Users\\TongNPZ\\Desktop\\my-app-2.0 - Copy (2)\\node_modules\\pdf-lib\\src\\core\\structures\\PDFPageTree.ts"],"sourcesContent":["import PDFArray from 'src/core/objects/PDFArray';\r\nimport PDFDict, { DictMap } from 'src/core/objects/PDFDict';\r\nimport PDFName from 'src/core/objects/PDFName';\r\nimport PDFNumber from 'src/core/objects/PDFNumber';\r\nimport PDFRef from 'src/core/objects/PDFRef';\r\nimport PDFContext from 'src/core/PDFContext';\r\nimport PDFPageLeaf from 'src/core/structures/PDFPageLeaf';\r\nimport { InvalidTargetIndexError, CorruptPageTreeError } from 'src/core/errors';\r\n\r\nexport type TreeNode = PDFPageTree | PDFPageLeaf;\r\n\r\nclass PDFPageTree extends PDFDict {\r\n  static withContext = (context: PDFContext, parent?: PDFRef) => {\r\n    const dict = new Map();\r\n    dict.set(PDFName.of('Type'), PDFName.of('Pages'));\r\n    dict.set(PDFName.of('Kids'), context.obj([]));\r\n    dict.set(PDFName.of('Count'), context.obj(0));\r\n    if (parent) dict.set(PDFName.of('Parent'), parent);\r\n    return new PDFPageTree(dict, context);\r\n  };\r\n\r\n  static fromMapWithContext = (map: DictMap, context: PDFContext) =>\r\n    new PDFPageTree(map, context);\r\n\r\n  Parent(): PDFPageTree | undefined {\r\n    return this.lookup(PDFName.of('Parent')) as PDFPageTree | undefined;\r\n  }\r\n\r\n  Kids(): PDFArray {\r\n    return this.lookup(PDFName.of('Kids'), PDFArray);\r\n  }\r\n\r\n  Count(): PDFNumber {\r\n    return this.lookup(PDFName.of('Count'), PDFNumber);\r\n  }\r\n\r\n  pushTreeNode(treeRef: PDFRef): void {\r\n    const Kids = this.Kids();\r\n    Kids.push(treeRef);\r\n  }\r\n\r\n  pushLeafNode(leafRef: PDFRef): void {\r\n    const Kids = this.Kids();\r\n    this.insertLeafKid(Kids.size(), leafRef);\r\n  }\r\n\r\n  /**\r\n   * Inserts the given ref as a leaf node of this page tree at the specified\r\n   * index (zero-based). Also increments the `Count` of each page tree in the\r\n   * hierarchy to accomodate the new page.\r\n   *\r\n   * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\r\n   * or `undefined` if it was inserted into the root node (the PDFPageTree upon\r\n   * which the method was first called).\r\n   */\r\n  insertLeafNode(leafRef: PDFRef, targetIndex: number): PDFRef | undefined {\r\n    const Kids = this.Kids();\r\n    const Count = this.Count().asNumber();\r\n\r\n    if (targetIndex > Count) {\r\n      throw new InvalidTargetIndexError(targetIndex, Count);\r\n    }\r\n\r\n    let leafsRemainingUntilTarget = targetIndex;\r\n    for (let idx = 0, len = Kids.size(); idx < len; idx++) {\r\n      if (leafsRemainingUntilTarget === 0) {\r\n        // Insert page and return\r\n        this.insertLeafKid(idx, leafRef);\r\n        return undefined;\r\n      }\r\n\r\n      const kidRef = Kids.get(idx) as PDFRef;\r\n      const kid = this.context.lookup(kidRef);\r\n\r\n      if (kid instanceof PDFPageTree) {\r\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\r\n          // Dig in\r\n          return (\r\n            kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef\r\n          );\r\n        } else {\r\n          // Move on\r\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\r\n        }\r\n      }\r\n\r\n      if (kid instanceof PDFPageLeaf) {\r\n        // Move on\r\n        leafsRemainingUntilTarget -= 1;\r\n      }\r\n    }\r\n\r\n    if (leafsRemainingUntilTarget === 0) {\r\n      // Insert page at the end and return\r\n      this.insertLeafKid(Kids.size(), leafRef);\r\n      return undefined;\r\n    }\r\n\r\n    // Should never get here if `targetIndex` is valid\r\n    throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\r\n  }\r\n\r\n  /**\r\n   * Removes the leaf node at the specified index (zero-based) from this page\r\n   * tree. Also decrements the `Count` of each page tree in the hierarchy to\r\n   * account for the removed page.\r\n   *\r\n   * If `prune` is true, then intermediate tree nodes will be removed from the\r\n   * tree if they contain 0 children after the leaf node is removed.\r\n   */\r\n  removeLeafNode(targetIndex: number, prune = true): void {\r\n    const Kids = this.Kids();\r\n    const Count = this.Count().asNumber();\r\n\r\n    if (targetIndex >= Count) {\r\n      throw new InvalidTargetIndexError(targetIndex, Count);\r\n    }\r\n\r\n    let leafsRemainingUntilTarget = targetIndex;\r\n    for (let idx = 0, len = Kids.size(); idx < len; idx++) {\r\n      const kidRef = Kids.get(idx) as PDFRef;\r\n      const kid = this.context.lookup(kidRef);\r\n\r\n      if (kid instanceof PDFPageTree) {\r\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\r\n          // Dig in\r\n          kid.removeLeafNode(leafsRemainingUntilTarget, prune);\r\n          if (prune && kid.Kids().size() === 0) Kids.remove(idx);\r\n          return;\r\n        } else {\r\n          // Move on\r\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\r\n        }\r\n      }\r\n\r\n      if (kid instanceof PDFPageLeaf) {\r\n        if (leafsRemainingUntilTarget === 0) {\r\n          // Remove page and return\r\n          this.removeKid(idx);\r\n          return;\r\n        } else {\r\n          // Move on\r\n          leafsRemainingUntilTarget -= 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Should never get here if `targetIndex` is valid\r\n    throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\r\n  }\r\n\r\n  ascend(visitor: (node: PDFPageTree) => any): void {\r\n    visitor(this);\r\n    const Parent = this.Parent();\r\n    if (Parent) Parent.ascend(visitor);\r\n  }\r\n\r\n  /** Performs a Post-Order traversal of this page tree */\r\n  traverse(visitor: (node: TreeNode, ref: PDFRef) => any): void {\r\n    const Kids = this.Kids();\r\n    for (let idx = 0, len = Kids.size(); idx < len; idx++) {\r\n      const kidRef = Kids.get(idx) as PDFRef;\r\n      const kid = this.context.lookup(kidRef) as TreeNode;\r\n      if (kid instanceof PDFPageTree) kid.traverse(visitor);\r\n      visitor(kid, kidRef);\r\n    }\r\n  }\r\n\r\n  private insertLeafKid(kidIdx: number, leafRef: PDFRef): void {\r\n    const Kids = this.Kids();\r\n\r\n    this.ascend((node) => {\r\n      const newCount = node.Count().asNumber() + 1;\r\n      node.set(PDFName.of('Count'), PDFNumber.of(newCount));\r\n    });\r\n\r\n    Kids.insert(kidIdx, leafRef);\r\n  }\r\n\r\n  private removeKid(kidIdx: number): void {\r\n    const Kids = this.Kids();\r\n\r\n    const kid = Kids.lookup(kidIdx);\r\n    if (kid instanceof PDFPageLeaf) {\r\n      this.ascend((node) => {\r\n        const newCount = node.Count().asNumber() - 1;\r\n        node.set(PDFName.of('Count'), PDFNumber.of(newCount));\r\n      });\r\n    }\r\n\r\n    Kids.remove(kidIdx);\r\n  }\r\n}\r\n\r\nexport default PDFPageTree;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
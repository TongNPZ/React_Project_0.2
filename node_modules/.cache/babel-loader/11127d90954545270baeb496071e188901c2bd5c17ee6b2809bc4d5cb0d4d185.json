{"ast":null,"code":"import { __extends, __spreadArrays } from \"tslib\";\nimport PDFName from \"./PDFName\";\nimport PDFNull from \"./PDFNull\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nvar PDFDict = /** @class */function (_super) {\n  __extends(PDFDict, _super);\n  function PDFDict(map, context) {\n    var _this = _super.call(this) || this;\n    _this.dict = map;\n    _this.context = context;\n    return _this;\n  }\n  PDFDict.prototype.keys = function () {\n    return Array.from(this.dict.keys());\n  };\n  PDFDict.prototype.values = function () {\n    return Array.from(this.dict.values());\n  };\n  PDFDict.prototype.entries = function () {\n    return Array.from(this.dict.entries());\n  };\n  PDFDict.prototype.set = function (key, value) {\n    this.dict.set(key, value);\n  };\n  PDFDict.prototype.get = function (key,\n  // TODO: `preservePDFNull` is for backwards compatibility. Should be\n  // removed in next breaking API change.\n  preservePDFNull) {\n    if (preservePDFNull === void 0) {\n      preservePDFNull = false;\n    }\n    var value = this.dict.get(key);\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  };\n  PDFDict.prototype.has = function (key) {\n    var value = this.dict.get(key);\n    return value !== undefined && value !== PDFNull;\n  };\n  PDFDict.prototype.lookupMaybe = function (key) {\n    var _a;\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    }\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    var preservePDFNull = types.includes(PDFNull);\n    var value = (_a = this.context).lookupMaybe.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  };\n  PDFDict.prototype.lookup = function (key) {\n    var _a;\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    }\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    var preservePDFNull = types.includes(PDFNull);\n    var value = (_a = this.context).lookup.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  };\n  PDFDict.prototype.delete = function (key) {\n    return this.dict.delete(key);\n  };\n  PDFDict.prototype.asMap = function () {\n    return new Map(this.dict);\n  };\n  /** Generate a random key that doesn't exist in current key set */\n  PDFDict.prototype.uniqueKey = function (tag) {\n    if (tag === void 0) {\n      tag = '';\n    }\n    var existingKeys = this.keys();\n    var key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    while (existingKeys.includes(key)) {\n      key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    }\n    return key;\n  };\n  PDFDict.prototype.clone = function (context) {\n    var clone = PDFDict.withContext(context || this.context);\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      clone.set(key, value);\n    }\n    return clone;\n  };\n  PDFDict.prototype.toString = function () {\n    var dictString = '<<\\n';\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      dictString += key.toString() + ' ' + value.toString() + '\\n';\n    }\n    dictString += '>>';\n    return dictString;\n  };\n  PDFDict.prototype.sizeInBytes = function () {\n    var size = 5;\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      size += key.sizeInBytes() + value.sizeInBytes() + 2;\n    }\n    return size;\n  };\n  PDFDict.prototype.copyBytesInto = function (buffer, offset) {\n    var initialOffset = offset;\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.Newline;\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      offset += key.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n      offset += value.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Newline;\n    }\n    buffer[offset++] = CharCodes.GreaterThan;\n    buffer[offset++] = CharCodes.GreaterThan;\n    return offset - initialOffset;\n  };\n  PDFDict.withContext = function (context) {\n    return new PDFDict(new Map(), context);\n  };\n  PDFDict.fromMapWithContext = function (map, context) {\n    return new PDFDict(map, context);\n  };\n  return PDFDict;\n}(PDFObject);\nexport default PDFDict;","map":{"version":3,"names":["PDFName","PDFNull","PDFObject","CharCodes","PDFDict","_super","__extends","map","context","_this","call","dict","prototype","keys","Array","from","values","entries","set","key","value","get","preservePDFNull","undefined","has","lookupMaybe","types","_i","arguments","length","includes","_a","apply","__spreadArrays","lookup","delete","asMap","Map","uniqueKey","tag","existingKeys","of","addRandomSuffix","clone","withContext","idx","len","toString","dictString","sizeInBytes","size","copyBytesInto","buffer","offset","initialOffset","LessThan","Newline","Space","GreaterThan","fromMapWithContext"],"sources":["C:\\Users\\TongNPZ\\Desktop\\my-app-2.0\\node_modules\\pdf-lib\\src\\core\\objects\\PDFDict.ts"],"sourcesContent":["import PDFArray from 'src/core/objects/PDFArray';\nimport PDFBool from 'src/core/objects/PDFBool';\nimport PDFHexString from 'src/core/objects/PDFHexString';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFNull from 'src/core/objects/PDFNull';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFObject from 'src/core/objects/PDFObject';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport PDFStream from 'src/core/objects/PDFStream';\nimport PDFString from 'src/core/objects/PDFString';\nimport PDFContext from 'src/core/PDFContext';\nimport CharCodes from 'src/core/syntax/CharCodes';\n\nexport type DictMap = Map<PDFName, PDFObject>;\n\nclass PDFDict extends PDFObject {\n  static withContext = (context: PDFContext) => new PDFDict(new Map(), context);\n\n  static fromMapWithContext = (map: DictMap, context: PDFContext) =>\n    new PDFDict(map, context);\n\n  readonly context: PDFContext;\n\n  private readonly dict: DictMap;\n\n  protected constructor(map: DictMap, context: PDFContext) {\n    super();\n    this.dict = map;\n    this.context = context;\n  }\n\n  keys(): PDFName[] {\n    return Array.from(this.dict.keys());\n  }\n\n  values(): PDFObject[] {\n    return Array.from(this.dict.values());\n  }\n\n  entries(): [PDFName, PDFObject][] {\n    return Array.from(this.dict.entries());\n  }\n\n  set(key: PDFName, value: PDFObject): void {\n    this.dict.set(key, value);\n  }\n\n  get(\n    key: PDFName,\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    preservePDFNull = false,\n  ): PDFObject | undefined {\n    const value = this.dict.get(key);\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  }\n\n  has(key: PDFName): boolean {\n    const value = this.dict.get(key);\n    return value !== undefined && value !== PDFNull;\n  }\n\n  lookupMaybe(key: PDFName, type: typeof PDFArray): PDFArray | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFBool): PDFBool | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFDict): PDFDict | undefined;\n  lookupMaybe(\n    key: PDFName,\n    type: typeof PDFHexString,\n  ): PDFHexString | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFName): PDFName | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFNull): typeof PDFNull | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFNumber): PDFNumber | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFStream): PDFStream | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFRef): PDFRef | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFString): PDFString | undefined;\n  lookupMaybe(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n  ): PDFString | PDFHexString | undefined;\n  lookupMaybe(\n    ref: PDFName,\n    type1: typeof PDFDict,\n    type2: typeof PDFStream,\n  ): PDFDict | PDFStream | undefined;\n  lookupMaybe(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n    type3: typeof PDFArray,\n  ): PDFString | PDFHexString | PDFArray | undefined;\n\n  lookupMaybe(key: PDFName, ...types: any[]) {\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    const preservePDFNull = types.includes(PDFNull);\n\n    const value = this.context.lookupMaybe(\n      this.get(key, preservePDFNull),\n      // @ts-ignore\n      ...types,\n    ) as any;\n\n    if (value === PDFNull && !preservePDFNull) return undefined;\n\n    return value;\n  }\n\n  lookup(key: PDFName): PDFObject | undefined;\n  lookup(key: PDFName, type: typeof PDFArray): PDFArray;\n  lookup(key: PDFName, type: typeof PDFBool): PDFBool;\n  lookup(key: PDFName, type: typeof PDFDict): PDFDict;\n  lookup(key: PDFName, type: typeof PDFHexString): PDFHexString;\n  lookup(key: PDFName, type: typeof PDFName): PDFName;\n  lookup(key: PDFName, type: typeof PDFNull): typeof PDFNull;\n  lookup(key: PDFName, type: typeof PDFNumber): PDFNumber;\n  lookup(key: PDFName, type: typeof PDFStream): PDFStream;\n  lookup(key: PDFName, type: typeof PDFRef): PDFRef;\n  lookup(key: PDFName, type: typeof PDFString): PDFString;\n  lookup(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n  ): PDFString | PDFHexString;\n  lookup(\n    ref: PDFName,\n    type1: typeof PDFDict,\n    type2: typeof PDFStream,\n  ): PDFDict | PDFStream;\n  lookup(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n    type3: typeof PDFArray,\n  ): PDFString | PDFHexString | PDFArray;\n\n  lookup(key: PDFName, ...types: any[]) {\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    const preservePDFNull = types.includes(PDFNull);\n\n    const value = this.context.lookup(\n      this.get(key, preservePDFNull),\n      // @ts-ignore\n      ...types,\n    ) as any;\n\n    if (value === PDFNull && !preservePDFNull) return undefined;\n\n    return value;\n  }\n\n  delete(key: PDFName): boolean {\n    return this.dict.delete(key);\n  }\n\n  asMap(): Map<PDFName, PDFObject> {\n    return new Map(this.dict);\n  }\n\n  /** Generate a random key that doesn't exist in current key set */\n  uniqueKey(tag = ''): PDFName {\n    const existingKeys = this.keys();\n    let key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    while (existingKeys.includes(key)) {\n      key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    }\n    return key;\n  }\n\n  clone(context?: PDFContext): PDFDict {\n    const clone = PDFDict.withContext(context || this.context);\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      clone.set(key, value);\n    }\n    return clone;\n  }\n\n  toString(): string {\n    let dictString = '<<\\n';\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      dictString += key.toString() + ' ' + value.toString() + '\\n';\n    }\n    dictString += '>>';\n    return dictString;\n  }\n\n  sizeInBytes(): number {\n    let size = 5;\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      size += key.sizeInBytes() + value.sizeInBytes() + 2;\n    }\n    return size;\n  }\n\n  copyBytesInto(buffer: Uint8Array, offset: number): number {\n    const initialOffset = offset;\n\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.Newline;\n\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      offset += key.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n      offset += value.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Newline;\n    }\n\n    buffer[offset++] = CharCodes.GreaterThan;\n    buffer[offset++] = CharCodes.GreaterThan;\n\n    return offset - initialOffset;\n  }\n}\n\nexport default PDFDict;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFFlateStream from \"./PDFFlateStream\";\nimport { bytesFor, Cache, reverseArray, sizeInBytes, sum } from \"../../utils\";\nexport var EntryType;\n(function (EntryType) {\n  EntryType[EntryType[\"Deleted\"] = 0] = \"Deleted\";\n  EntryType[EntryType[\"Uncompressed\"] = 1] = \"Uncompressed\";\n  EntryType[EntryType[\"Compressed\"] = 2] = \"Compressed\";\n})(EntryType || (EntryType = {}));\n/**\n * Entries should be added using the [[addDeletedEntry]],\n * [[addUncompressedEntry]], and [[addCompressedEntry]] methods\n * **in order of ascending object number**.\n */\nvar PDFCrossRefStream = /** @class */function (_super) {\n  __extends(PDFCrossRefStream, _super);\n  function PDFCrossRefStream(dict, entries, encode) {\n    if (encode === void 0) {\n      encode = true;\n    }\n    var _this = _super.call(this, dict, encode) || this;\n    // Returns an array of integer pairs for each subsection of the cross ref\n    // section, where each integer pair represents:\n    //   firstObjectNumber(OfSection), length(OfSection)\n    _this.computeIndex = function () {\n      var subsections = [];\n      var subsectionLength = 0;\n      for (var idx = 0, len = _this.entries.length; idx < len; idx++) {\n        var currEntry = _this.entries[idx];\n        var prevEntry = _this.entries[idx - 1];\n        if (idx === 0) {\n          subsections.push(currEntry.ref.objectNumber);\n        } else if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {\n          subsections.push(subsectionLength);\n          subsections.push(currEntry.ref.objectNumber);\n          subsectionLength = 0;\n        }\n        subsectionLength += 1;\n      }\n      subsections.push(subsectionLength);\n      return subsections;\n    };\n    _this.computeEntryTuples = function () {\n      var entryTuples = new Array(_this.entries.length);\n      for (var idx = 0, len = _this.entries.length; idx < len; idx++) {\n        var entry = _this.entries[idx];\n        if (entry.type === EntryType.Deleted) {\n          var type = entry.type,\n            nextFreeObjectNumber = entry.nextFreeObjectNumber,\n            ref = entry.ref;\n          entryTuples[idx] = [type, nextFreeObjectNumber, ref.generationNumber];\n        }\n        if (entry.type === EntryType.Uncompressed) {\n          var type = entry.type,\n            offset = entry.offset,\n            ref = entry.ref;\n          entryTuples[idx] = [type, offset, ref.generationNumber];\n        }\n        if (entry.type === EntryType.Compressed) {\n          var type = entry.type,\n            objectStreamRef = entry.objectStreamRef,\n            index = entry.index;\n          entryTuples[idx] = [type, objectStreamRef.objectNumber, index];\n        }\n      }\n      return entryTuples;\n    };\n    _this.computeMaxEntryByteWidths = function () {\n      var entryTuples = _this.entryTuplesCache.access();\n      var widths = [0, 0, 0];\n      for (var idx = 0, len = entryTuples.length; idx < len; idx++) {\n        var _a = entryTuples[idx],\n          first = _a[0],\n          second = _a[1],\n          third = _a[2];\n        var firstSize = sizeInBytes(first);\n        var secondSize = sizeInBytes(second);\n        var thirdSize = sizeInBytes(third);\n        if (firstSize > widths[0]) widths[0] = firstSize;\n        if (secondSize > widths[1]) widths[1] = secondSize;\n        if (thirdSize > widths[2]) widths[2] = thirdSize;\n      }\n      return widths;\n    };\n    _this.entries = entries || [];\n    _this.entryTuplesCache = Cache.populatedBy(_this.computeEntryTuples);\n    _this.maxByteWidthsCache = Cache.populatedBy(_this.computeMaxEntryByteWidths);\n    _this.indexCache = Cache.populatedBy(_this.computeIndex);\n    dict.set(PDFName.of('Type'), PDFName.of('XRef'));\n    return _this;\n  }\n  PDFCrossRefStream.prototype.addDeletedEntry = function (ref, nextFreeObjectNumber) {\n    var type = EntryType.Deleted;\n    this.entries.push({\n      type: type,\n      ref: ref,\n      nextFreeObjectNumber: nextFreeObjectNumber\n    });\n    this.entryTuplesCache.invalidate();\n    this.maxByteWidthsCache.invalidate();\n    this.indexCache.invalidate();\n    this.contentsCache.invalidate();\n  };\n  PDFCrossRefStream.prototype.addUncompressedEntry = function (ref, offset) {\n    var type = EntryType.Uncompressed;\n    this.entries.push({\n      type: type,\n      ref: ref,\n      offset: offset\n    });\n    this.entryTuplesCache.invalidate();\n    this.maxByteWidthsCache.invalidate();\n    this.indexCache.invalidate();\n    this.contentsCache.invalidate();\n  };\n  PDFCrossRefStream.prototype.addCompressedEntry = function (ref, objectStreamRef, index) {\n    var type = EntryType.Compressed;\n    this.entries.push({\n      type: type,\n      ref: ref,\n      objectStreamRef: objectStreamRef,\n      index: index\n    });\n    this.entryTuplesCache.invalidate();\n    this.maxByteWidthsCache.invalidate();\n    this.indexCache.invalidate();\n    this.contentsCache.invalidate();\n  };\n  PDFCrossRefStream.prototype.clone = function (context) {\n    var _a = this,\n      dict = _a.dict,\n      entries = _a.entries,\n      encode = _a.encode;\n    return PDFCrossRefStream.of(dict.clone(context), entries.slice(), encode);\n  };\n  PDFCrossRefStream.prototype.getContentsString = function () {\n    var entryTuples = this.entryTuplesCache.access();\n    var byteWidths = this.maxByteWidthsCache.access();\n    var value = '';\n    for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {\n      var _a = entryTuples[entryIdx],\n        first = _a[0],\n        second = _a[1],\n        third = _a[2];\n      var firstBytes = reverseArray(bytesFor(first));\n      var secondBytes = reverseArray(bytesFor(second));\n      var thirdBytes = reverseArray(bytesFor(third));\n      for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {\n        value += (firstBytes[idx] || 0).toString(2);\n      }\n      for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {\n        value += (secondBytes[idx] || 0).toString(2);\n      }\n      for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {\n        value += (thirdBytes[idx] || 0).toString(2);\n      }\n    }\n    return value;\n  };\n  PDFCrossRefStream.prototype.getUnencodedContents = function () {\n    var entryTuples = this.entryTuplesCache.access();\n    var byteWidths = this.maxByteWidthsCache.access();\n    var buffer = new Uint8Array(this.getUnencodedContentsSize());\n    var offset = 0;\n    for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {\n      var _a = entryTuples[entryIdx],\n        first = _a[0],\n        second = _a[1],\n        third = _a[2];\n      var firstBytes = reverseArray(bytesFor(first));\n      var secondBytes = reverseArray(bytesFor(second));\n      var thirdBytes = reverseArray(bytesFor(third));\n      for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {\n        buffer[offset++] = firstBytes[idx] || 0;\n      }\n      for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {\n        buffer[offset++] = secondBytes[idx] || 0;\n      }\n      for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {\n        buffer[offset++] = thirdBytes[idx] || 0;\n      }\n    }\n    return buffer;\n  };\n  PDFCrossRefStream.prototype.getUnencodedContentsSize = function () {\n    var byteWidths = this.maxByteWidthsCache.access();\n    var entryWidth = sum(byteWidths);\n    return entryWidth * this.entries.length;\n  };\n  PDFCrossRefStream.prototype.updateDict = function () {\n    _super.prototype.updateDict.call(this);\n    var byteWidths = this.maxByteWidthsCache.access();\n    var index = this.indexCache.access();\n    var context = this.dict.context;\n    this.dict.set(PDFName.of('W'), context.obj(byteWidths));\n    this.dict.set(PDFName.of('Index'), context.obj(index));\n  };\n  PDFCrossRefStream.create = function (dict, encode) {\n    if (encode === void 0) {\n      encode = true;\n    }\n    var stream = new PDFCrossRefStream(dict, [], encode);\n    stream.addDeletedEntry(PDFRef.of(0, 65535), 0);\n    return stream;\n  };\n  PDFCrossRefStream.of = function (dict, entries, encode) {\n    if (encode === void 0) {\n      encode = true;\n    }\n    return new PDFCrossRefStream(dict, entries, encode);\n  };\n  return PDFCrossRefStream;\n}(PDFFlateStream);\nexport default PDFCrossRefStream;","map":{"version":3,"names":["PDFName","PDFRef","PDFFlateStream","bytesFor","Cache","reverseArray","sizeInBytes","sum","EntryType","PDFCrossRefStream","_super","__extends","dict","entries","encode","_this","call","computeIndex","subsections","subsectionLength","idx","len","length","currEntry","prevEntry","push","ref","objectNumber","computeEntryTuples","entryTuples","Array","entry","type","Deleted","nextFreeObjectNumber","generationNumber","Uncompressed","offset","Compressed","objectStreamRef","index","computeMaxEntryByteWidths","entryTuplesCache","access","widths","_a","first","second","third","firstSize","secondSize","thirdSize","populatedBy","maxByteWidthsCache","indexCache","set","of","prototype","addDeletedEntry","invalidate","contentsCache","addUncompressedEntry","addCompressedEntry","clone","context","slice","getContentsString","byteWidths","value","entryIdx","entriesLen","firstBytes","secondBytes","thirdBytes","toString","getUnencodedContents","buffer","Uint8Array","getUnencodedContentsSize","entryWidth","updateDict","obj","create","stream"],"sources":["C:\\Users\\TongNPZ\\Desktop\\my-app-2.0\\node_modules\\pdf-lib\\src\\core\\structures\\PDFCrossRefStream.ts"],"sourcesContent":["import PDFDict from 'src/core/objects/PDFDict';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport PDFContext from 'src/core/PDFContext';\nimport PDFFlateStream from 'src/core/structures/PDFFlateStream';\nimport { bytesFor, Cache, reverseArray, sizeInBytes, sum } from 'src/utils';\n\nexport enum EntryType {\n  Deleted = 0,\n  Uncompressed = 1,\n  Compressed = 2,\n}\n\nexport interface DeletedEntry {\n  type: EntryType.Deleted;\n  ref: PDFRef;\n  nextFreeObjectNumber: number;\n}\n\nexport interface UncompressedEntry {\n  type: EntryType.Uncompressed;\n  ref: PDFRef;\n  offset: number;\n}\n\nexport interface CompressedEntry {\n  type: EntryType.Compressed;\n  ref: PDFRef;\n  objectStreamRef: PDFRef;\n  index: number;\n}\n\nexport type Entry = DeletedEntry | UncompressedEntry | CompressedEntry;\n\nexport type EntryTuple = [number, number, number];\n\n/**\n * Entries should be added using the [[addDeletedEntry]],\n * [[addUncompressedEntry]], and [[addCompressedEntry]] methods\n * **in order of ascending object number**.\n */\nclass PDFCrossRefStream extends PDFFlateStream {\n  static create = (dict: PDFDict, encode = true) => {\n    const stream = new PDFCrossRefStream(dict, [], encode);\n    stream.addDeletedEntry(PDFRef.of(0, 65535), 0);\n    return stream;\n  };\n\n  static of = (dict: PDFDict, entries: Entry[], encode = true) =>\n    new PDFCrossRefStream(dict, entries, encode);\n\n  private readonly entries: Entry[];\n  private readonly entryTuplesCache: Cache<EntryTuple[]>;\n  private readonly maxByteWidthsCache: Cache<[number, number, number]>;\n  private readonly indexCache: Cache<number[]>;\n\n  private constructor(dict: PDFDict, entries?: Entry[], encode = true) {\n    super(dict, encode);\n\n    this.entries = entries || [];\n    this.entryTuplesCache = Cache.populatedBy(this.computeEntryTuples);\n    this.maxByteWidthsCache = Cache.populatedBy(this.computeMaxEntryByteWidths);\n    this.indexCache = Cache.populatedBy(this.computeIndex);\n\n    dict.set(PDFName.of('Type'), PDFName.of('XRef'));\n  }\n\n  addDeletedEntry(ref: PDFRef, nextFreeObjectNumber: number) {\n    const type = EntryType.Deleted;\n    this.entries.push({ type, ref, nextFreeObjectNumber });\n    this.entryTuplesCache.invalidate();\n    this.maxByteWidthsCache.invalidate();\n    this.indexCache.invalidate();\n    this.contentsCache.invalidate();\n  }\n\n  addUncompressedEntry(ref: PDFRef, offset: number) {\n    const type = EntryType.Uncompressed;\n    this.entries.push({ type, ref, offset });\n    this.entryTuplesCache.invalidate();\n    this.maxByteWidthsCache.invalidate();\n    this.indexCache.invalidate();\n    this.contentsCache.invalidate();\n  }\n\n  addCompressedEntry(ref: PDFRef, objectStreamRef: PDFRef, index: number) {\n    const type = EntryType.Compressed;\n    this.entries.push({ type, ref, objectStreamRef, index });\n    this.entryTuplesCache.invalidate();\n    this.maxByteWidthsCache.invalidate();\n    this.indexCache.invalidate();\n    this.contentsCache.invalidate();\n  }\n\n  clone(context?: PDFContext): PDFCrossRefStream {\n    const { dict, entries, encode } = this;\n    return PDFCrossRefStream.of(dict.clone(context), entries.slice(), encode);\n  }\n\n  getContentsString(): string {\n    const entryTuples = this.entryTuplesCache.access();\n    const byteWidths = this.maxByteWidthsCache.access();\n    let value = '';\n\n    for (\n      let entryIdx = 0, entriesLen = entryTuples.length;\n      entryIdx < entriesLen;\n      entryIdx++\n    ) {\n      const [first, second, third] = entryTuples[entryIdx];\n\n      const firstBytes = reverseArray(bytesFor(first));\n      const secondBytes = reverseArray(bytesFor(second));\n      const thirdBytes = reverseArray(bytesFor(third));\n\n      for (let idx = byteWidths[0] - 1; idx >= 0; idx--) {\n        value += (firstBytes[idx] || 0).toString(2);\n      }\n      for (let idx = byteWidths[1] - 1; idx >= 0; idx--) {\n        value += (secondBytes[idx] || 0).toString(2);\n      }\n      for (let idx = byteWidths[2] - 1; idx >= 0; idx--) {\n        value += (thirdBytes[idx] || 0).toString(2);\n      }\n    }\n\n    return value;\n  }\n\n  getUnencodedContents(): Uint8Array {\n    const entryTuples = this.entryTuplesCache.access();\n    const byteWidths = this.maxByteWidthsCache.access();\n    const buffer = new Uint8Array(this.getUnencodedContentsSize());\n\n    let offset = 0;\n    for (\n      let entryIdx = 0, entriesLen = entryTuples.length;\n      entryIdx < entriesLen;\n      entryIdx++\n    ) {\n      const [first, second, third] = entryTuples[entryIdx];\n\n      const firstBytes = reverseArray(bytesFor(first));\n      const secondBytes = reverseArray(bytesFor(second));\n      const thirdBytes = reverseArray(bytesFor(third));\n\n      for (let idx = byteWidths[0] - 1; idx >= 0; idx--) {\n        buffer[offset++] = firstBytes[idx] || 0;\n      }\n      for (let idx = byteWidths[1] - 1; idx >= 0; idx--) {\n        buffer[offset++] = secondBytes[idx] || 0;\n      }\n      for (let idx = byteWidths[2] - 1; idx >= 0; idx--) {\n        buffer[offset++] = thirdBytes[idx] || 0;\n      }\n    }\n\n    return buffer;\n  }\n\n  getUnencodedContentsSize(): number {\n    const byteWidths = this.maxByteWidthsCache.access();\n    const entryWidth = sum(byteWidths);\n    return entryWidth * this.entries.length;\n  }\n\n  updateDict(): void {\n    super.updateDict();\n\n    const byteWidths = this.maxByteWidthsCache.access();\n    const index = this.indexCache.access();\n\n    const { context } = this.dict;\n    this.dict.set(PDFName.of('W'), context.obj(byteWidths));\n    this.dict.set(PDFName.of('Index'), context.obj(index));\n  }\n\n  // Returns an array of integer pairs for each subsection of the cross ref\n  // section, where each integer pair represents:\n  //   firstObjectNumber(OfSection), length(OfSection)\n  private computeIndex = (): number[] => {\n    const subsections: number[] = [];\n\n    let subsectionLength = 0;\n    for (let idx = 0, len = this.entries.length; idx < len; idx++) {\n      const currEntry = this.entries[idx];\n      const prevEntry = this.entries[idx - 1];\n\n      if (idx === 0) {\n        subsections.push(currEntry.ref.objectNumber);\n      } else if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {\n        subsections.push(subsectionLength);\n        subsections.push(currEntry.ref.objectNumber);\n        subsectionLength = 0;\n      }\n\n      subsectionLength += 1;\n    }\n    subsections.push(subsectionLength);\n\n    return subsections;\n  };\n\n  private computeEntryTuples = (): EntryTuple[] => {\n    const entryTuples: EntryTuple[] = new Array(this.entries.length);\n\n    for (let idx = 0, len = this.entries.length; idx < len; idx++) {\n      const entry = this.entries[idx];\n      if (entry.type === EntryType.Deleted) {\n        const { type, nextFreeObjectNumber, ref } = entry;\n        entryTuples[idx] = [type, nextFreeObjectNumber, ref.generationNumber];\n      }\n      if (entry.type === EntryType.Uncompressed) {\n        const { type, offset, ref } = entry;\n        entryTuples[idx] = [type, offset, ref.generationNumber];\n      }\n      if (entry.type === EntryType.Compressed) {\n        const { type, objectStreamRef, index } = entry;\n        entryTuples[idx] = [type, objectStreamRef.objectNumber, index];\n      }\n    }\n\n    return entryTuples;\n  };\n\n  private computeMaxEntryByteWidths = (): [number, number, number] => {\n    const entryTuples = this.entryTuplesCache.access();\n    const widths: [number, number, number] = [0, 0, 0];\n\n    for (let idx = 0, len = entryTuples.length; idx < len; idx++) {\n      const [first, second, third] = entryTuples[idx];\n\n      const firstSize = sizeInBytes(first);\n      const secondSize = sizeInBytes(second);\n      const thirdSize = sizeInBytes(third);\n\n      if (firstSize > widths[0]) widths[0] = firstSize;\n      if (secondSize > widths[1]) widths[1] = secondSize;\n      if (thirdSize > widths[2]) widths[2] = thirdSize;\n    }\n\n    return widths;\n  };\n}\n\nexport default PDFCrossRefStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { Struct } from './Struct.js';\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\nexport class VersionedStruct extends Struct {\n  constructor(type) {\n    let versions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n  decode(stream, parent) {\n    let length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const res = this._setup(stream, parent, length);\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n    const fields = this.versions[res.version];\n    if (fields == null) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n    this._parseFields(stream, res, fields);\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n  size(val, parent) {\n    let includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n    const fields = this.versions[val.version];\n    if (fields == null) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n    return size;\n  }\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}","map":{"version":3,"names":["Struct","getPath","object","pathArray","reduce","prevObj","key","VersionedStruct","constructor","type","versions","arguments","length","undefined","versionPath","split","decode","stream","parent","res","_setup","version","header","_parseFields","fields","Error","process","call","size","val","includePointers","preEncode","ctx","pointerSize","encode","pointers","startOffset","pos","pointerOffset","i","ptr"],"sources":["C:/Users/TongNPZ/Desktop/my-app-2.0/node_modules/restructure/src/VersionedStruct.js"],"sourcesContent":["import {Struct} from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type, versions = {}) {\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent, length = 0) {\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n\n  size(val, parent, includePointers = true) {\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
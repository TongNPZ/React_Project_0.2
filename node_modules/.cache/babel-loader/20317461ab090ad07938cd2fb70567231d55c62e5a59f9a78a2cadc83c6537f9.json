{"ast":null,"code":"import { decodeFromBase64DataUri } from \"./base64\";\nimport { charFromCode } from \"./strings\";\nexport var last = function (array) {\n  return array[array.length - 1];\n};\n// export const dropLast = <T>(array: T[]): T[] =>\n// array.slice(0, array.length - 1);\nexport var typedArrayFor = function (value) {\n  if (value instanceof Uint8Array) return value;\n  var length = value.length;\n  var typedArray = new Uint8Array(length);\n  for (var idx = 0; idx < length; idx++) {\n    typedArray[idx] = value.charCodeAt(idx);\n  }\n  return typedArray;\n};\nexport var mergeIntoTypedArray = function () {\n  var arrays = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    arrays[_i] = arguments[_i];\n  }\n  var arrayCount = arrays.length;\n  var typedArrays = [];\n  for (var idx = 0; idx < arrayCount; idx++) {\n    var element = arrays[idx];\n    typedArrays[idx] = element instanceof Uint8Array ? element : typedArrayFor(element);\n  }\n  var totalSize = 0;\n  for (var idx = 0; idx < arrayCount; idx++) {\n    totalSize += arrays[idx].length;\n  }\n  var merged = new Uint8Array(totalSize);\n  var offset = 0;\n  for (var arrIdx = 0; arrIdx < arrayCount; arrIdx++) {\n    var arr = typedArrays[arrIdx];\n    for (var byteIdx = 0, arrLen = arr.length; byteIdx < arrLen; byteIdx++) {\n      merged[offset++] = arr[byteIdx];\n    }\n  }\n  return merged;\n};\nexport var mergeUint8Arrays = function (arrays) {\n  var totalSize = 0;\n  for (var idx = 0, len = arrays.length; idx < len; idx++) {\n    totalSize += arrays[idx].length;\n  }\n  var mergedBuffer = new Uint8Array(totalSize);\n  var offset = 0;\n  for (var idx = 0, len = arrays.length; idx < len; idx++) {\n    var array = arrays[idx];\n    mergedBuffer.set(array, offset);\n    offset += array.length;\n  }\n  return mergedBuffer;\n};\nexport var arrayAsString = function (array) {\n  var str = '';\n  for (var idx = 0, len = array.length; idx < len; idx++) {\n    str += charFromCode(array[idx]);\n  }\n  return str;\n};\nexport var byAscendingId = function (a, b) {\n  return a.id - b.id;\n};\nexport var sortedUniq = function (array, indexer) {\n  var uniq = [];\n  for (var idx = 0, len = array.length; idx < len; idx++) {\n    var curr = array[idx];\n    var prev = array[idx - 1];\n    if (idx === 0 || indexer(curr) !== indexer(prev)) {\n      uniq.push(curr);\n    }\n  }\n  return uniq;\n};\n// Arrays and TypedArrays in JS both have .reverse() methods, which would seem\n// to negate the need for this function. However, not all runtimes support this\n// method (e.g. React Native). This function compensates for that fact.\nexport var reverseArray = function (array) {\n  var arrayLen = array.length;\n  for (var idx = 0, len = Math.floor(arrayLen / 2); idx < len; idx++) {\n    var leftIdx = idx;\n    var rightIdx = arrayLen - idx - 1;\n    var temp = array[idx];\n    array[leftIdx] = array[rightIdx];\n    array[rightIdx] = temp;\n  }\n  return array;\n};\nexport var sum = function (array) {\n  var total = 0;\n  for (var idx = 0, len = array.length; idx < len; idx++) {\n    total += array[idx];\n  }\n  return total;\n};\nexport var range = function (start, end) {\n  var arr = new Array(end - start);\n  for (var idx = 0, len = arr.length; idx < len; idx++) {\n    arr[idx] = start + idx;\n  }\n  return arr;\n};\nexport var pluckIndices = function (arr, indices) {\n  var plucked = new Array(indices.length);\n  for (var idx = 0, len = indices.length; idx < len; idx++) {\n    plucked[idx] = arr[indices[idx]];\n  }\n  return plucked;\n};\nexport var canBeConvertedToUint8Array = function (input) {\n  return input instanceof Uint8Array || input instanceof ArrayBuffer || typeof input === 'string';\n};\nexport var toUint8Array = function (input) {\n  if (typeof input === 'string') {\n    return decodeFromBase64DataUri(input);\n  } else if (input instanceof ArrayBuffer) {\n    return new Uint8Array(input);\n  } else if (input instanceof Uint8Array) {\n    return input;\n  } else {\n    throw new TypeError('`input` must be one of `string | ArrayBuffer | Uint8Array`');\n  }\n};","map":{"version":3,"names":["decodeFromBase64DataUri","charFromCode","last","array","length","typedArrayFor","value","Uint8Array","typedArray","idx","charCodeAt","mergeIntoTypedArray","arrays","_i","arguments","arrayCount","typedArrays","element","totalSize","merged","offset","arrIdx","arr","byteIdx","arrLen","mergeUint8Arrays","len","mergedBuffer","set","arrayAsString","str","byAscendingId","a","b","id","sortedUniq","indexer","uniq","curr","prev","push","reverseArray","arrayLen","Math","floor","leftIdx","rightIdx","temp","sum","total","range","start","end","Array","pluckIndices","indices","plucked","canBeConvertedToUint8Array","input","ArrayBuffer","toUint8Array","TypeError"],"sources":["C:\\Users\\TongNPZ\\Desktop\\my-app-2.0\\node_modules\\pdf-lib\\src\\utils\\arrays.ts"],"sourcesContent":["import { decodeFromBase64DataUri } from 'src/utils/base64';\nimport { charFromCode } from 'src/utils/strings';\n\nexport const last = <T>(array: T[]): T => array[array.length - 1];\n\n// export const dropLast = <T>(array: T[]): T[] =>\n// array.slice(0, array.length - 1);\n\nexport const typedArrayFor = (value: string | Uint8Array): Uint8Array => {\n  if (value instanceof Uint8Array) return value;\n  const length = value.length;\n  const typedArray = new Uint8Array(length);\n  for (let idx = 0; idx < length; idx++) {\n    typedArray[idx] = value.charCodeAt(idx);\n  }\n  return typedArray;\n};\n\nexport const mergeIntoTypedArray = (...arrays: (string | Uint8Array)[]) => {\n  const arrayCount = arrays.length;\n\n  const typedArrays: Uint8Array[] = [];\n  for (let idx = 0; idx < arrayCount; idx++) {\n    const element = arrays[idx];\n    typedArrays[idx] =\n      element instanceof Uint8Array ? element : typedArrayFor(element);\n  }\n\n  let totalSize = 0;\n  for (let idx = 0; idx < arrayCount; idx++) {\n    totalSize += arrays[idx].length;\n  }\n\n  const merged = new Uint8Array(totalSize);\n  let offset = 0;\n  for (let arrIdx = 0; arrIdx < arrayCount; arrIdx++) {\n    const arr = typedArrays[arrIdx];\n    for (let byteIdx = 0, arrLen = arr.length; byteIdx < arrLen; byteIdx++) {\n      merged[offset++] = arr[byteIdx];\n    }\n  }\n\n  return merged;\n};\n\nexport const mergeUint8Arrays = (arrays: Uint8Array[]): Uint8Array => {\n  let totalSize = 0;\n  for (let idx = 0, len = arrays.length; idx < len; idx++) {\n    totalSize += arrays[idx].length;\n  }\n\n  const mergedBuffer = new Uint8Array(totalSize);\n  let offset = 0;\n  for (let idx = 0, len = arrays.length; idx < len; idx++) {\n    const array = arrays[idx];\n    mergedBuffer.set(array, offset);\n    offset += array.length;\n  }\n\n  return mergedBuffer;\n};\n\nexport const arrayAsString = (array: Uint8Array | number[]): string => {\n  let str = '';\n  for (let idx = 0, len = array.length; idx < len; idx++) {\n    str += charFromCode(array[idx]);\n  }\n  return str;\n};\n\nexport const byAscendingId = <T extends { id: any }>(a: T, b: T) => a.id - b.id;\n\nexport const sortedUniq = <T>(array: T[], indexer: (elem: T) => any): T[] => {\n  const uniq: T[] = [];\n\n  for (let idx = 0, len = array.length; idx < len; idx++) {\n    const curr = array[idx];\n    const prev = array[idx - 1];\n    if (idx === 0 || indexer(curr) !== indexer(prev)) {\n      uniq.push(curr);\n    }\n  }\n\n  return uniq;\n};\n\n// Arrays and TypedArrays in JS both have .reverse() methods, which would seem\n// to negate the need for this function. However, not all runtimes support this\n// method (e.g. React Native). This function compensates for that fact.\nexport const reverseArray = (array: Uint8Array) => {\n  const arrayLen = array.length;\n  for (let idx = 0, len = Math.floor(arrayLen / 2); idx < len; idx++) {\n    const leftIdx = idx;\n    const rightIdx = arrayLen - idx - 1;\n    const temp = array[idx];\n\n    array[leftIdx] = array[rightIdx];\n    array[rightIdx] = temp;\n  }\n  return array;\n};\n\nexport const sum = (array: number[] | Uint8Array): number => {\n  let total = 0;\n  for (let idx = 0, len = array.length; idx < len; idx++) {\n    total += array[idx];\n  }\n  return total;\n};\n\nexport const range = (start: number, end: number): number[] => {\n  const arr = new Array(end - start);\n  for (let idx = 0, len = arr.length; idx < len; idx++) {\n    arr[idx] = start + idx;\n  }\n  return arr;\n};\n\nexport const pluckIndices = <T>(arr: T[], indices: number[]) => {\n  const plucked = new Array<T>(indices.length);\n  for (let idx = 0, len = indices.length; idx < len; idx++) {\n    plucked[idx] = arr[indices[idx]];\n  }\n  return plucked;\n};\n\nexport const canBeConvertedToUint8Array = (\n  input: any,\n): input is string | ArrayBuffer | Uint8Array =>\n  input instanceof Uint8Array ||\n  input instanceof ArrayBuffer ||\n  typeof input === 'string';\n\nexport const toUint8Array = (input: string | ArrayBuffer | Uint8Array) => {\n  if (typeof input === 'string') {\n    return decodeFromBase64DataUri(input);\n  } else if (input instanceof ArrayBuffer) {\n    return new Uint8Array(input);\n  } else if (input instanceof Uint8Array) {\n    return input;\n  } else {\n    throw new TypeError(\n      '`input` must be one of `string | ArrayBuffer | Uint8Array`',\n    );\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}